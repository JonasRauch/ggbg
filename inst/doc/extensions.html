<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Brodie Gaslam" />


<title>Writing Ggplot2 Extensions</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



<style type="text/css">
body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.5;
}
#header {
text-align: center;
}
#TOC {
clear: both;

padding: 4px;
width: 100%;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 1em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
h3.subtitle {
margin-top: -23px;
}
pre, code {
background-color: #EEE;
color: #333;
white-space: pre-wrap; 

}
code {font-size: 85%;}
pre {
border: 2px solid #EEE;
overflow: auto;

margin: 5px 0px;
padding: 5px 10px;
}
pre:not([class]) {
color: #353;

}
div.sourceCode pre, div.sourceCode code {
background-color: #FAFAFA;
}
div.sourceCode pre{

}
div.sourceCode + pre,
div.sourceCode + div.diffobj_container {
margin-top: -5px;
}
div.diffobj_container pre{
line-height: 1.3;
}

code {
font-family: Consolas, Monaco, 'Courier New', monospace;
}
p > code, li > code, h1 > code, h2 > code, h3 > code,
h4 > code, h5 > code, h6 > code {
padding: 2px 0px;
line-height: 1;
font-weight: bold;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
padding-bottom: 3px;
font-size: 35px;
line-height: 40px;
border-bottom: 1px solid #999;
}
h2 {
border-bottom: 1px solid #999;
padding-top: 5px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
padding-top: 5px;
font-size: 120%;
}
h4 {

color: #777;
font-size: 105%;
}
h4.author {display: none;}
h4.date {margin-top: -20px;}
h5, h6 {

font-size: 105%;
}
a {
color: #2255dd;
font-weight: bold;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #555; } 
code > span.fl { color: #555; } 
code > span.ch { color: #555; } 
code > span.st { color: #40a070; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Writing Ggplot2 Extensions</h1>
<h4 class="author"><em>Brodie Gaslam</em></h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#overview">Overview</a><ul>
<li><a href="#its-all-in-the-printing">It’s All in the Printing</a></li>
<li><a href="#extension-mechanism">Extension Mechanism</a></li>
<li><a href="#data-and-processing-patterns">Data and Processing Patterns</a></li>
</ul></li>
<li><a href="#method-outline">Method Outline</a><ul>
<li><a href="#ggplot_build">ggplot_build</a></li>
<li><a href="#ggplot_gtable">ggplot_gtable</a></li>
</ul></li>
<li><a href="#method-details">Method Details</a><ul>
<li><a href="#example-plot">Example Plot</a></li>
<li><a href="#layerlayer_data">Layer$layer_data</a></li>
<li><a href="#objectsetup_params-and-objectsetup_data-setup_param-setup_data">Object<span class="math inline">\(setup_params And Object\)</span>setup_data {setup_param-setup_data}</a></li>
<li><a href="#facetcompute_layout">Facet$compute_layout</a></li>
<li><a href="#facetmap_data">Facet$map_data</a></li>
<li><a href="#layercompute_aesthetic">Layer$compute_aesthetic</a></li>
<li><a href="#scaletransform_df">Scale$transform_df</a></li>
<li><a href="#layoutmap_position">Layout$map_position</a></li>
<li><a href="#stat-compute">Stat$compute_layer/panel/group</a></li>
<li><a href="#layermap_statistic">Layer$map_statistic</a></li>
<li><a href="#position-compute">Position$compute_layer/panel</a></li>
<li><a href="#layoutsetup_panel_params">Layout$setup_panel_params</a></li>
<li><a href="#train-map-scale">Train/Map Scales</a></li>
<li><a href="#geomuse_defaults">Geom$use_defaults</a></li>
<li><a href="#geomdraw_panel">Geom$draw_panel</a></li>
<li><a href="#ggplot_gtable-1">ggplot_gtable</a></li>
</ul></li>
<li><a href="#hooks">Hooks</a></li>
<li><a href="#understanding-the-data-object">Understanding the <code>data</code> Object</a></li>
<li><a href="#grid-stuff">Grid Stuff</a></li>
<li><a href="#glossary">Glossary</a></li>
</ul>
</div>

<p><em>DRAFT</em></p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This document is an unofficial reference for developers looking to extend <code>ggplot2</code>. It supplements to existing documentation by providing more detail about how the extension mechanism interacts with other parts of the <code>ggplot2</code> plot building process. It is based on examination of the sources of <code>ggplot2</code> circa 5/2018 (version 2.3 pre-release), and may become out of date as <code>ggplot2</code> evolves.</p>
<p>We assume the reader is familiar with using <code>ggplot2</code> for generating plots, and that the reader has previously reviewed:</p>
<ul>
<li><code>?ggproto</code> for an introduction to the <code>ggplot2</code> object oriented programming system.</li>
<li><code>?ggplot2::ggplot2-ggproto</code> for the major <code>ggproto</code> objects used by <code>ggplot2</code>.</li>
<li><code>vignette(package='ggplot2', 'extending-ggplot2')</code> for the official documentation on extending <code>ggplot2</code>.</li>
</ul>
<p>There are four major sections to this document:</p>
<ol style="list-style-type: decimal">
<li>Overview: A high level look at the process of converting data and user <code>ggplot2</code> plot specifications into a plot.</li>
<li>Process Outline: The listing of all the key function calls used by <code>ggplot2</code> to generate the plot. This gives you a sense for where your extension fits in relation to the rest of the process. Most steps in the outline are hyperlinked to the “Process Detail” section.</li>
<li>Process Detail: More detail on the important steps in the plot generation process, including descriptions of inputs, outputs, and other relevant information for anyone looking to modify those steps.</li>
<li>Definitions: Definitions of key terms. These are hyperlinked throughout the document.</li>
</ol>
</div>
<div id="overview" class="section level2">
<h2>Overview</h2>
<div id="its-all-in-the-printing" class="section level3">
<h3>It’s All in the Printing</h3>
<p>Four major steps are required to produce <code>ggplot</code>:</p>
<ol style="list-style-type: decimal">
<li>Specify (<code>ggplot() + ...</code>): user specifies what the plot should look like with <code>geom_*</code>, <code>stat_*</code>, <code>scale_*</code>, etc..</li>
<li>Build (<code>ggplot_build</code>): <code>ggplot2</code> manipulates the data as directed by the user plot specification (e.g. apply stats, position adjustments, etc).</li>
<li>Create Grobs (<code>ggplot_gtable</code>): <code>ggplot2</code> translates the data into <code>grid</code> graphical objects (grobs).</li>
<li>Render (<code>grid.draw</code>): display the graphical objects on a graphics device.</li>
</ol>
<p>Step 1 is done directly by the user and will be familiar to all <code>ggplot2</code> users. Steps 2-4 are triggered by the printing of a <code>ggplot2</code> object, as shown by this simplified version of <code>print.ggplot</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1">print.ggplot &lt;-<span class="st"> </span><span class="cf">function</span> (x, ...) {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  data &lt;-<span class="st"> </span><span class="kw">ggplot_build</span>(x)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  gtable &lt;-<span class="st"> </span><span class="kw">ggplot_gtable</span>(data)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">grid.draw</span>(gtable)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">}</a></code></pre></div>
<p>Almost all the work <code>ggplot2</code> does is in these last three steps. In order to successfully extend <code>ggplot2</code> it helps to understand what happens in them, particularly the <code>ggplot_build</code> and <code>ggplot_gtable</code> steps. This documents focuses mostly on the <code>ggplot_build</code> step.</p>
</div>
<div id="extension-mechanism" class="section level3">
<h3>Extension Mechanism</h3>
<p><code>ggplot2</code> is extended by defining <a href="#ggproto"><code>ggproto</code> objects</a> that inherit from the existing <a href="#ggproto-geom"><code>Geom</code></a>, <a href="#ggproto-geom"><code>Stat</code></a>, <a href="#ggproto-geom"><code>Position</code></a>, <code>Scale</code>, <code>Coord</code> and/or <code>Facet</code> <code>ggproto</code> objects. <code>ggproto</code> objects contain both data and functions (a.k.a. methods), so this allows users to override <code>ggplot2</code> default behavior by providing new <a href="#ggproto-method"><code>ggproto</code> methods</a>.</p>
<p>For example, if we want to define a new <code>Geom</code> “x”, we create a <code>GeomX</code> <code>ggproto</code> object that extends <code>Geom</code>, and we provide a <a href="#layer-function">layer function</a> that associates it and other <code>ggproto</code> objects and parameters with a <a href="#ggproto-layer"><code>Layer</code> <code>ggproto</code> object</a>.</p>
<p><strong>DON’T LOVE TRANSITION FROM geom_x TO geom_point HERE</strong></p>
<p>Once the layer function is done with the associations it returns the <code>Layer</code> <code>ggproto</code> object.</p>
<p><code>ggproto</code> objects contain logic (i.e. functions, a.k.a. methods) in addition to data. <code>ggplot_build</code> and <code>ggplot_gtable</code> will use these <code>ggproto</code> methods to generate the plots. In this way the layer extension mechanism allows us to modify the plot generation mechanism.</p>
</div>
<div id="data-and-processing-patterns" class="section level3">
<h3>Data and Processing Patterns</h3>
<p>The structure of <code>ggplot2</code> plots consists of:</p>
<ul>
<li>a plot</li>
<li>that contains layers as specified by <code>geom_*</code> / <code>stat_*</code></li>
<li>that contain panels as specified by <code>facet_*</code></li>
<li>that contain groups as specified by the <code>group</code> aesthetic, or implicitly by the interaction of all the discrete aesthetics in the plot</li>
</ul>
<p>Each layer has data associated to it. It can be either layer specific data, or data inherited from the plot itself (i.e. the data from <code>ggplot(data, ...)</code>). The data is then divided across the panels and then across the groups by adding the <code>PANEL</code> and <code>group</code> variables to the data.</p>
<p>Other methods present in most <code>Geom</code>, <code>Stat</code>, and <code>Position</code> that we are interested in include:</p>
<ul>
<li><code>compute_[layer|panel|group]()</code></li>
<li><code>draw_[layer|panel|group]()</code></li>
</ul>
<p>Typically a <code>ggproto</code> object will have one set or the other. For example <code>Geom</code> objects have <code>draw_*</code> methods, whereas <code>Stat</code> objects have <code>compute_*</code> methods. The method structure mirrors the data structure. The <code>*_layer</code> methods are called on the layer data, and they will typically call the <code>*_panel</code> methods with the corresponding subset of the data, which then call the <code>*_group</code> methods with the corresponding sub-subset of data.</p>
<p>The recommend approach to creating custom stats and geoms involves overriding the <code>[compute|draw]_[panel|group]</code> methods for the <code>Geom*</code> and <code>Stat*</code> <code>ggproto</code> objects.</p>
</div>
</div>
<div id="method-outline" class="section level2">
<h2>Method Outline</h2>
<div id="ggplot_build" class="section level3">
<h3>ggplot_build</h3>
<p><code>ggplot_build</code> starts with the input data and the plot specification. It then proceeds through several steps that sequentially transform the data by adding and/or recomputing variables, or in the case of statistics recomputing the entire data. In addition to transforming the data, the build process also updates and computes meta data for scales, facets, etc. The work is carried out by the methods of <code>ggproto</code> objects provided implicitly via the plot specification.</p>
<p>A simplified outline of the methods called by <code>ggplot_build</code> follows. This is not comprehensive and hides some of the logic. For example, some methods are called for every layer, or every panel, and that is not shown here. This outline is intended to give a rough idea of what happens in what order. It also acts as an index to more comprehensive documentation for the key methods. Almost all methods you would override when extending <code>ggplot2</code> should be listed here so you can search for them. For example, if you are creating a new <code>Geom</code>, search for “Geom” in the index below. For context, we include calls to methods for the <code>Layer</code>, <code>Layout</code>, <code>Facet</code>, and <code>Coord</code> objects even though you are less likely to modify them.</p>
<ul>
<li><a href="#layer-layer_data"><code>Layer$layer_data</code></a>: assign data to layer</li>
<li><code>Layout$setup</code>:
<ul>
<li><a href="#setup_params-setup_data"><code>Facet$setup_params</code></a>: unused by common <code>Facet</code> objects.</li>
<li><a href="#setup_params-setup_data"><code>Facet$setup_data</code></a>: unused by common <code>Facet</code> objects.</li>
<li><a href="#setup_params-setup_data"><code>Coord$setup_data</code></a>: unused by common <code>Coord</code> objects.</li>
<li><a href="#facet-compute_layout"><code>Facet$compute_layout</code></a>: generate facet meta data.</li>
<li><code>Coord$setup_layout</code>:</li>
<li><a href="#facet-map-data"><code>Facet$map_data</code></a>: add the <code>PANEL</code> variable that maps data rows to facets.</li>
</ul></li>
<li><a href="#layer-compute-aesthetics"><code>Layer$compute_aesthetics</code></a>: compute aesthetics, add <code>group</code> variable.</li>
<li><a href="#scale-transform-df"><code>Scale$transform_df</code></a>: apply scale transformations to aesthetics.</li>
<li><code>Layout$train_position</code>: initialize and <a href="#train-scale">train</a> position scales.</li>
<li><a href="#layout-map_position"><code>Layout$map_position</code></a>: <a href="#map-scale">map</a> <a href="#position-scale">position scales</a>.</li>
<li><code>Layer$compute_statistic</code>: recompute data with statistics.
<ul>
<li><a href="#setup_params-setup_data"><code>Stat$setup_params</code></a>: adjust parameters.</li>
<li><a href="#setup_params-setup_data"><code>Stat$setup_data</code></a>: adjust data.</li>
<li><a href="#stat-compute"><code>Stat$compute_layer</code></a>: apply statistic to each layer.</li>
<li><a href="#stat-compute"><code>Stat$compute_panel</code></a>: apply statistic to each panel.</li>
<li><a href="#stat-compute"><code>Stat$compute_group</code></a>: apply statistic to each group.</li>
</ul></li>
<li><code>Layer$map_statistic</code>: re-computes and rescales aesthetics using the data produced by <a href="#stat-compute"><code>Stat$compute_layer</code></a>.</li>
<li><code>scales_add_missing</code>: adds default scales for the layer for the <code>x</code> and <code>y</code> aesthetics if they are part of the layer specification and are missing.</li>
<li><code>Layer$compute_geom_1</code>: prepare <code>Geom</code> data for each layer.
<ul>
<li><a href="#setup_params-setup_data"><code>Geom$setup_data</code></a>: adjust data.</li>
<li><code>check_required_aesthetics</code>.</li>
</ul></li>
<li><code>Layer$compute_position</code>: apply position adjustments.
<ul>
<li><a href="#setup_params-setup_data"><code>Position$setup_params</code></a>: adjust parameters.</li>
<li><a href="#setup_params-setup_data"><code>Position$setup_data</code></a>: adjust data.</li>
<li><a href="#position-compute_layer"><code>Position$compute_layer</code></a>: adjust positions for layer.</li>
<li><a href="#position-compute_panel"><code>Position$compute_panel</code></a>: adjust positions for panel.</li>
</ul></li>
<li><code>Layout$reset_scales</code>: remove any previous <a href="#scale-train">scale training</a>.</li>
<li><code>Layout$train_position</code>: <a href="#scale-train">re-train</a> the <a href="#ggproto-position-scale">position scales</a>.</li>
<li><a href="#layout-setup_panel_params"><code>Layout$setup_panel_params</code></a>: compute meta-data for panels.</li>
<li><a href="#layout-map_position"><code>Layout$map_position</code></a>: re-map <a href="#ggproto-position-scale">position scales</a>.</li>
<li><a href="#train-map-scale"><code>scales_train_df</code></a>: <a href="#train-scale">train</a> non-<a href="#position-scales">position scales</a>.</li>
<li><a href="#train-map-scale"><code>scales_map_df</code></a>: <a href="#map-scale">map</a> non-<a href="#position-scales">position scales</a>.</li>
<li><code>Layer$compute_geom_2</code>: add defaults and aesthetic parameters.
<ul>
<li><a href="#geom-use_defaults"><code>Geom$use_defaults</code></a>.</li>
</ul></li>
<li><code>Layer$finish_statistics</code>:
<ul>
<li><code>Stat$finish_layer</code>: typically unused, gives stat one more chance to modify data after it is <a href="#map-scale">mapped</a>.</li>
</ul></li>
<li><code>Layout$finish_data</code>:
<ul>
<li><code>Facet$finish_data</code>: typically unused, gives <code>Facet</code> one last chance to modify data with access to the <a href="#layout-layout">layout</a> meta data and the position scales.</li>
</ul></li>
</ul>
</div>
<div id="ggplot_gtable" class="section level3">
<h3>ggplot_gtable</h3>
<p>TBD.</p>
</div>
</div>
<div id="method-details" class="section level2">
<h2>Method Details</h2>
<div id="example-plot" class="section level3">
<h3>Example Plot</h3>
<p>We illustrate inputs and outputs to some of the methods documented in this section with the following plot:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="dt">loc=</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">2</span>,</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="dt">val=</span>(<span class="dv">5</span><span class="op">:</span><span class="dv">8</span>)<span class="op">^</span><span class="dv">2</span>,</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="dt">grp=</span><span class="kw">c</span>(<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>),</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="dt">pnl=</span><span class="kw">c</span>(<span class="st">'P1'</span>, <span class="st">'P1'</span>, <span class="st">'P2'</span>, <span class="st">'P2'</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">library</span>(ggplot2)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(dat, <span class="kw">aes</span>(<span class="dt">x=</span>loc, <span class="dt">y=</span>val, <span class="dt">fill=</span>grp)) <span class="op">+</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="st">  </span><span class="kw">stat_bin2d</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">position=</span><span class="st">&quot;jitter&quot;</span>, <span class="dt">shape=</span><span class="dv">21</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span>pnl, <span class="dt">scales=</span><span class="st">&quot;free_x&quot;</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="st">  </span><span class="kw">scale_x_sqrt</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="st">  </span><span class="kw">scale_y_sqrt</span>()</a></code></pre></div>
<p>It involves a standard layer, a statistic layer, it has facets, and it scales the <a href="#position-aesthetic">position aesthetics</a>.</p>
</div>
<div id="layerlayer_data" class="section level3">
<h3>Layer$layer_data</h3>
<p>For each layer, this process assigns the data to be used, which is either the data specified in the <code>geom_*</code> / <code>stat_*</code> call if any, or if not the data specified in the <code>ggplot()</code> call. Because neither layer in the plot had data they both acquire the plot data.</p>
</div>
<div id="objectsetup_params-and-objectsetup_data-setup_param-setup_data" class="section level3">
<h3>Object<span class="math inline">\(setup_params And Object\)</span>setup_data {setup_param-setup_data}</h3>
<div id="description" class="section level4">
<h4>Description</h4>
<p><code>ggplot2</code> has a complex specification system. In most cases, the user input specification is relatively simple, but <code>ggplot2</code> then needs to set or compute default values for derived variables and parameters. To assist with this most of the <a href="#ggproto"><code>ggproto</code> objects</a> have <code>setup_params</code> and <code>setup_data</code> methods. These are often called after some of the initial setup has been done (e.g. assigning layer data) so that they can use this information to update the data or parameters.</p>
<p>For example, <code>Facet$setup_params</code> is called with a list containing the plot data and every layer data after the data is associated to each layer. This gives the method the opportunity to update the parameters in the context of the entirety of the data.</p>
<p>The <code>setup_data</code> methods provide an opportunity to update the data, also after the data has been assigned to layers, and after the parameters have been updated with the <code>setup_params</code> methods. An example is how some <code>Geoms</code> will add <code>xmin</code> and <code>xmax</code> aesthetics computed from existing <code>x</code> and <code>width</code> aesthetics with the <code>setup_data</code> method.</p>
</div>
<div id="signature" class="section level4">
<h4>Signature</h4>
<p><code>$setup_params([self], data, params)</code> <code>$setup_data([self], data, params)</code></p>
<p>The <code>self</code> parameter, if present, can appear anywhere in the signature. The other two parameters must be in the relative order shown above.</p>
</div>
<div id="parameters" class="section level4">
<h4>Parameters</h4>
<ul>
<li><code>self</code>: optional parameter, if present will point to the <code>ggproto</code> object the method belongs to.</li>
<li><code>data</code>: the layer data. Depending on which <code>ggproto</code> object the <code>setup_*</code> method belongs to it may have undergone scale transformation and/or mapping. See the <a href="#method-outline">method outline</a> to get an idea of the state of the data by the time it gets to the <code>setup_*</code> method in question.</li>
<li><code>params</code>: a list of the parameters provided to the <a href="#layer-function">layer function</a> that match the parameters of the <code>$[compute|draw]_panel</code> of <code>self</code>, and if that method has a <code>...</code> parameter, then also the parameters of the <code>$[compute|draw]_group</code> method.</li>
</ul>
</div>
<div id="value" class="section level4">
<h4>Value</h4>
<p>For <code>$setup_params</code>, a list of the parameters associated with the corresponding <a href="#ggproto"><code>ggproto</code></a> object.</p>
<p>For <code>$setup_data</code>, the updated data.</p>
</div>
<div id="see-also" class="section level4">
<h4>See Also</h4>
<p>Some of the default methods are documented in <code>?'ggplot2-ggproto'</code>. The definition of <a href="#ggproto-method">ggproto methods</a> for details about the <code>self</code> parameter.</p>
</div>
</div>
<div id="facetcompute_layout" class="section level3">
<h3>Facet$compute_layout</h3>
<p>Assigns a panel, row, column, and position scale ids to each facet. It is possible to have multiple position scales in a plot when the scales are “free”.</p>
<p>This data is stored in the <code>$layout</code> {#layout-layout} member of the <a href="#ggproto-layout"><code>Layout</code> <code>ggproto</code></a> object. This is what it looks like for our <a href="#example-plot">example plot</a>:</p>
<pre><code>  PANEL ROW COL pnl SCALE_X SCALE_Y
1     1   1   1  P1       1       1
2     2   1   2  P2       2       1</code></pre>
<p>Our data has two facets (panels) arranged across two columns and in one row. There is one <code>y</code> scale, and two <code>x</code> scales because with set “free_x” in the facet specification for the plot.</p>
</div>
<div id="facetmap_data" class="section level3">
<h3>Facet$map_data</h3>
<p>Add the <code>PANEL</code> variable to the data. Here we show the effect it has on the data of the first layer:</p>
<pre><code>&lt; input                  
&gt; output                 
@@ 1,5 / 1,5 @@          
&lt;   loc val grp pnl      
&gt;   loc val grp pnl PANEL
&lt; 1   1  25   A  P1      
&gt; 1   1  25   A  P1     1
&lt; 2   4  36   B  P1      
&gt; 2   4  36   B  P1     1
&lt; 3   9  49   B  P2      
&gt; 3   9  49   B  P2     2
&lt; 4  16  64   C  P2      
&gt; 4  16  64   C  P2     2</code></pre>
</div>
<div id="layercompute_aesthetic" class="section level3">
<h3>Layer$compute_aesthetic</h3>
<p>For each layer, evaluates all the non-computed <code>aes(...)</code> expressions and replace the data variables with the resulting aesthetics. Computed aesthetics (i.e. those containing calls to <code>stat</code>) are calculated later <strong>WHEN?</strong>. This step also infers the <code>group</code> aesthetic from the interaction of categorical variables specified in <code>aes(...)</code>.</p>
<p>Here we show the effect on one of the layer’s data:</p>
<pre><code>&lt; input                   
&gt; output                  
@@ 1,5 / 1,5 @@           
&lt;   loc val grp pnl PANEL 
&gt;    x  y fill PANEL group
&lt; 1   1  25   A  P1     1 
&gt; 1  1 25    A     1     1
&lt; 2   4  36   B  P1     1 
&gt; 2  4 36    B     1     2
&lt; 3   9  49   B  P2     2 
&gt; 3  9 49    B     2     2
&lt; 4  16  64   C  P2     2 
&gt; 4 16 64    C     2     3</code></pre>
<p>The variable have changed to be the aesthetics, and we gain the <code>group</code> variable.</p>
</div>
<div id="scaletransform_df" class="section level3">
<h3>Scale$transform_df</h3>
<p>This is applies scale transformations to each layer. In our example, we use <code>scale_*_sqrt</code>. Here is the effect on the data for one of the layers:</p>
<p>&lt; trans.input<br />
&gt; trans.output<br />
@@ 1,5 / 1,5 @@<br />
x y fill PANEL group &lt; 1 1 25 A 1 1 &gt; 1 1 5 A 1 1<br />
&lt; 2 4 36 B 1 2 &gt; 2 2 6 B 1 2<br />
&lt; 3 9 49 B 2 2 &gt; 3 3 7 B 2 2<br />
&lt; 4 16 64 C 2 3 &gt; 4 4 8 C 2 3</p>
<p>The transformation is applied to all the aesthetics that are associated with the scale. For example, continuous <code>x</code> scales will transform the <code>x</code> aesthetic, but also <code>xmin</code>, <code>xmax</code>, <code>xend</code>, <code>xintercept</code>, and several others.</p>
</div>
<div id="layoutmap_position" class="section level3">
<h3>Layout$map_position</h3>
<p>For each layer, <a href="#ggproto-scale-map">map</a> data with <a href="#position-scale">position scales</a>.</p>
<p>For continuous variables this in theory would rescale the continuous position aesthetics (e.g. <code>x</code>, <code>xmin</code>, <code>xmax</code>, <code>y</code>, etc.) into the display range ( e.g. 0-1), but because “the coordinate system takes care of it” the only thing this does is handle NAs and convert integer aesthetics to numeric.</p>
<p>Discrete variables are mapped onto integers for each value. This only happens once even though the build process calls <code>Layout$map_position</code> twice. The second time it will only be applied to aesthetics that have not already been converted (e.g those added by a <code>stat</code>).</p>
</div>
<div id="stat-compute" class="section level3">
<h3>Stat$compute_layer/panel/group</h3>
<div id="description-1" class="section level4">
<h4>Description</h4>
<p>These methods are responsible for applying a statistic to the layer data and returning the result as the new layer data. Typically you would modify one of the layer, panel, or group methods, listed here in order of increasing specificity. If possible, you should modify the most specific method (e.g. the group method) as that requires the least work. If you need more control over the process you can override on of the more general methods. If you do this, for example by overriding the panel method, you will be responsible for splitting the data into groups, processing the groups, and re-assembling the data.</p>
<p><code>$compute_layer</code> is called on each layer of the plot. The default layer and panel method respectively run the panel and group methods over each panel and group. This is why you can just override the more specific methods.</p>
</div>
<div id="signature-1" class="section level4">
<h4>Signature</h4>
<p><code>$compute_layer([self], data, params, layout)</code> <code>$compute_panel([self], data, scales, ...)</code> <code>$compute_group([self], data, scales)</code></p>
</div>
<div id="parameters-1" class="section level4">
<h4>Parameters</h4>
<ul>
<li><code>self</code>: optional parameter, if present will point to the <code>Stat</code> <code>ggproto</code> object the method belongs to.</li>
<li><code>data</code>: the layer data for <code>$compute_layer</code>, a subset of the layer data corresponding to a panel for <code>$compute_panel</code>, or a subset of the panel data corresponding to a group for <code>$compute_group</code>.</li>
<li><code>params</code>: the parameter list as matched to the <code>$compute_panel/group</code> methods by the <a href="#layer-function">layer function</a>.</li>
<li><code>layout</code>: the <a href="#ggproto-layout"><code>Layout</code> <code>ggproto</code></a> object for the plot, provided mostly so that <code>$compute_layer</code> can extract the position scales to pass on to <code>$compute_panel</code> and <code>$compute_group</code>.</li>
<li><code>scales</code>: a list with the position scales for the panel. This can be useful if values in <code>params</code> need to be transformed by the scales (e.g. breaks that correspond to <code>x</code> values). <code>scales[['x']]</code> contains the <code>x</code> scale, and <code>scales[['y']]</code> contains the <code>y</code> scale.</li>
</ul>
</div>
<div id="value-1" class="section level4">
<h4>Value</h4>
<p>Statistics can completely change the data. Here is what the input to <code>Stat$compute_layer</code> looks like in <a href="#example-plot">example plot</a>:</p>
<p>x y fill PANEL group 1 1 5 A 1 1 2 2 6 B 1 2 3 3 7 B 2 2 4 4 8 C 2 3</p>
<p>And if you have not modified the layer method, then the input into <code>Stat$compute_panel</code> will look like (for the first panel):</p>
<pre><code>  x y fill PANEL group
1 1 5    A     1     1
2 2 6    B     1     2</code></pre>
<p>And if you have not modified the panel method, the input into <code>Stat$group_panel</code> will look like (for the first group of the first panel):</p>
<pre><code>  x y fill PANEL group
1 1 5    A     1     1</code></pre>
<p>In the <a href="#example-plot">example plot</a> <code>StatBin2d</code> overrides the <code>$compute_group</code> method. The result for the first group of the first panel is then:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">structure</span>(<span class="kw">list</span>(<span class="dt">xbin =</span> 1L, <span class="dt">ybin =</span> 1L, <span class="dt">value =</span> <span class="dv">1</span>, <span class="dt">x =</span> <span class="fl">1.01666666666667</span>, <span class="dt">width =</span> <span class="fl">0.0333333400000002</span>, <span class="dt">y =</span> <span class="fl">5.05</span>, <span class="dt">height =</span> <span class="fl">0.10000002</span>, <span class="dt">count =</span> <span class="dv">1</span>, <span class="dt">density =</span> <span class="dv">1</span>), <span class="dt">.Names =</span> <span class="kw">c</span>(<span class="st">&quot;xbin&quot;</span>, <span class="st">&quot;ybin&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;x&quot;</span>, <span class="st">&quot;width&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;height&quot;</span>, <span class="st">&quot;count&quot;</span>, <span class="st">&quot;density&quot;</span>), <span class="dt">row.names =</span> 1L, <span class="dt">class =</span> <span class="st">&quot;data.frame&quot;</span>)</a></code></pre></div>
<pre><code>  xbin ybin value x width y height count density
1    1    1     1 1 0.033 5    0.1     1       1</code></pre>
<p>If you only override the <code>$compute_group</code> method, <code>$compute_panel</code> will add back any variables that are lost by <code>$compute_group</code>, although it does so by recycling the first values of those variables. In this case <code>$compute_panel</code> adds back the <code>fill</code>, <code>PANEL</code>, and <code>group</code> variables that were dropped by <code>$compute_group</code>.</p>
<p>The final output after <code>$compute_panel</code> and <code>$compute_layer</code> stitch back the groups and panels together:</p>
<p>In this case the number of rows in input and output happens to be the same because each of our groups only has one row in it, but that is not a requirement.</p>
<p>Ultimately, this step should produce data that once processed by <a href="#layer-map_statistic"><code>Layer$map_statistic</code></a> has all the required aesthetics required by the <a href="ggproto-geom"><code>Geom</code></a> associated with the layer.</p>
</div>
</div>
<div id="layermap_statistic" class="section level3">
<h3>Layer$map_statistic</h3>
<div id="description-2" class="section level4">
<h4>Description</h4>
<p>Since <a href="#stat-compute"><code>Stat$compute_layer</code></a> creates new data, we need to re-apply some of the early computations and transformations on the aesthetics. <code>$map_statistic</code> effectively applies the following to our stat-recomputed data:</p>
<ul>
<li><a href="#layer-compute-aesthetic"><code>Layer$compute_aesthetic</code></a> (kind of).</li>
<li><a href="#scales-transform-df"><code>Scales$transform_df</code></a>.</li>
</ul>
<p><code>$map_statistic</code> does not actually call <code>$compute_aesthetic</code>, but it does most of what <code>$compute_aesthetic</code> does. There are differences, for example this <a href="#comupted-aesthetic">computed aesthetics</a> are evaluated, whereas they are not by <code>$compute_aesthetic</code>.</p>
</div>
<div id="signature-2" class="section level4">
<h4>Signature</h4>
<p><code>$map_statistic([self], data, plot)</code></p>
</div>
<div id="parameters-2" class="section level4">
<h4>Parameters</h4>
<ul>
<li><code>self</code>: optional parameter, if present will point to the <code>Stat</code> <code>ggproto</code> object the method belongs to.</li>
<li><code>data</code>: the data for a layer after the statistic has been applied.</li>
<li><code>plot</code>: the <code>Plot</code> <code>ggproto</code> object.</li>
</ul>
</div>
<div id="value-2" class="section level4">
<h4>Value</h4>
<p>The data, with <a href="#computed-aesthetic">computed</a> and other aesthetics specified by the stat <a href="#layer-function">layer function</a> that were dropped by the statistic added back.</p>
</div>
</div>
<div id="position-compute" class="section level3">
<h3>Position$compute_layer/panel</h3>
<div id="description-3" class="section level4">
<h4>Description</h4>
<p>These methods adjust <a href="#position-aesthetic">position aesthetics</a> in the data for groups of elements that are considered to overlap. For example, both <code>position_dodge</code> and <code>position_stack</code> group data by <code>xmin</code> aesthetic value (either user provided, or derived from <code>x</code> and <code>width</code> or some such), and then resolve any <code>xmin</code> overlaps by allocating the available width for each distinct <code>group</code> within, or modifying <code>ymin</code> / <code>ymax</code> values so elements will stack.</p>
<p><code>$compute_layer</code> is called on each layer of the plot, and the default method then calls <code>$compute_panel</code> on each panel in the layer. Unlike with the <a href="#stat-compute">stat computation</a> methods there is not a default <code>$compute_group</code> method since typically the position adjustment must be made accounting for all the groups positions simultaneously.</p>
</div>
<div id="signature-3" class="section level4">
<h4>Signature</h4>
<p><code>$compute_layer([self], data, params, layout)</code> <code>$compute_panel([self], data, params, scale)</code></p>
</div>
<div id="parameters-3" class="section level4">
<h4>Parameters</h4>
<ul>
<li><code>self</code>: optional parameter, if present will point to the <code>Stat</code> <code>ggproto</code> object the method belongs to.</li>
<li><code>data</code>: the layer data for <code>$compute_layer</code>, a subset of the layer data corresponding to a panel for <code>$compute_panel</code>.</li>
<li><code>params</code>: the parameter list as matched to the <code>$compute_panel/group</code> methods by the <a href="#layer-function">layer function</a>.</li>
<li><code>layout</code>: the <a href="#ggproto-layout"><code>Layout</code> <code>ggproto</code></a> object for the plot, provided mostly so that <code>$compute_layer</code> can extract the position scales to pass on to <code>$compute_panel</code> and <code>$compute_group</code>.</li>
<li><code>scales</code>: a list with the position scales for the panel. This can be useful if values in <code>params</code> need to be transformed by the scales (e.g. breaks that correspond to <code>x</code> values). <code>scales[['x']]</code> contains the <code>x</code> scale, and <code>scales[['y']]</code> contains the <code>y</code> scale.</li>
</ul>
</div>
<div id="value-3" class="section level4">
<h4>Value</h4>
<p>The data with positions adjusted. Here is how <code>$compute_layer</code> changes the input data in our <a href="#example-plot">example plot</a> that uses <code>position_jitter</code>:</p>
<pre><code>Error in diffPrint(pos.input, pos.output): could not find function &quot;diffPrint&quot;</code></pre>
<p>This adjust the <code>x</code> and <code>y</code> aesthetics, though it would also adjust any other <a href="#position-aesthetic">position aesthetics</a> if they existed in the data.</p>
<p>If you overrode the <code>$compute_panel</code> method instead of <code>$compute_layer</code> as <code>position_jitter</code> does, each input and output should be the same, except subset by the <code>PANEL</code> variable.</p>
</div>
</div>
<div id="layoutsetup_panel_params" class="section level3">
<h3>Layout$setup_panel_params</h3>
<p>Generates a list that, for each panel, contains a list of the key meta data for the <a href="#position-scale">position scales</a>, including the range, labels, location of major and minor breaks, and axis order, amongst others. The list is then stored in <code>Layout$panel_params</code>, by reference. Here is what this list looks like in our <a href="#example-plot">example plot</a>:</p>
<pre><code>List of 2
 $ :List of 14
  ..$ x.range       : num [1:2] 0.576 2.438
  ..$ x.labels      : chr [1:5] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
  ..$ x.major       : num [1:5] 0.228 0.45 0.621 0.765 0.892
  ..$ x.minor       : num [1:11] 0.0055 0.1167 0.2279 0.3391 0.4503 ...
  ..$ x.major_source: num [1:5] 1 1.41 1.73 2 2.24
  ..$ x.minor_source: num [1:11] 0.586 0.793 1 1.207 1.414 ...
  ..$ x.arrange     : chr [1:2] &quot;secondary&quot; &quot;primary&quot;
  ..$ y.range       : num [1:2] 4.81 8.41
  ..$ y.labels      : chr [1:5] &quot;30&quot; &quot;40&quot; &quot;50&quot; &quot;60&quot; ...
  ..$ y.major       : num [1:5] 0.185 0.42 0.627 0.815 0.987
  ..$ y.minor       : num [1:10] 0.0675 0.185 0.3026 0.4202 0.5238 ...
  ..$ y.major_source: num [1:5] 5.48 6.32 7.07 7.75 8.37
  ..$ y.minor_source: num [1:10] 5.05 5.48 5.9 6.32 6.7 ...
  ..$ y.arrange     : chr [1:2] &quot;primary&quot; &quot;secondary&quot;
 $ :List of 14
  ..$ x.range       : num [1:2] 2.95 4.05
  ..$ x.labels      : chr [1:4] &quot;10&quot; &quot;12&quot; &quot;14&quot; &quot;16&quot;
  ..$ x.major       : num [1:4] 0.193 0.467 0.72 0.955
  ..$ x.minor       : num [1:8] 0.0558 0.193 0.3302 0.4674 0.5935 ...
  ..$ x.major_source: num [1:4] 3.16 3.46 3.74 4
  ..$ x.minor_source: num [1:8] 3.01 3.16 3.31 3.46 3.6 ...
  ..$ x.arrange     : chr [1:2] &quot;secondary&quot; &quot;primary&quot;
  ..$ y.range       : num [1:2] 4.81 8.41
  ..$ y.labels      : chr [1:5] &quot;30&quot; &quot;40&quot; &quot;50&quot; &quot;60&quot; ...
  ..$ y.major       : num [1:5] 0.185 0.42 0.627 0.815 0.987
  ..$ y.minor       : num [1:10] 0.0675 0.185 0.3026 0.4202 0.5238 ...
  ..$ y.major_source: num [1:5] 5.48 6.32 7.07 7.75 8.37
  ..$ y.minor_source: num [1:10] 5.05 5.48 5.9 6.32 6.7 ...
  ..$ y.arrange     : chr [1:2] &quot;primary&quot; &quot;secondary&quot;</code></pre>
</div>
<div id="train-map-scale" class="section level3">
<h3>Train/Map Scales</h3>
<div id="description-4" class="section level4">
<h4>Description</h4>
<p><code>scales_train_df</code> runs the <a href="#train-scale">scale training</a> on every aesthetic corresponding to the provided scales (non-position scales in <code>ggplot_build</code>) across every layer.</p>
<p><code>scales_map_df</code> <a href="#map-scale">maps</a>every aesthetic corresponding to the provided scales (non-position scales in <code>ggplot_build</code>) across every layer.</p>
</div>
<div id="value-4" class="section level4">
<h4>Value</h4>
<p><code>scales_train_df</code> only update the scale meta data. <code>scales_map_df</code> will modify the data, as in our <a href="#example-plot">example plot</a>:</p>
<pre><code>Error in diffStr(map.scale.input, map.scale.output): could not find function &quot;diffStr&quot;</code></pre>
</div>
</div>
<div id="geomuse_defaults" class="section level3">
<h3>Geom$use_defaults</h3>
<div id="description-5" class="section level4">
<h4>Description</h4>
<p>For each layer, add the geom default aesthetics and aesthetics specified as non-mapping parameters to the <a href="#layer-function">layer function</a> to the data. It is worth noting that any aesthetics added by this mechanism are not <a href="#map-scale">mapped by the scales</a>.</p>
</div>
<div id="signature-4" class="section level4">
<h4>Signature</h4>
<p><code>$use_defaults([self], data, params)</code></p>
</div>
<div id="parameters-4" class="section level4">
<h4>Parameters</h4>
<ul>
<li><code>self</code>: optional parameter, if present will point to the <code>Geom</code> <code>ggproto</code> object this method belongs to.</li>
<li><code>data</code>: the layer data for.</li>
<li><code>params</code>: the parameter list as matched to the aesthetics supported by the <code>Geom</code> (i.e. <code>Geom$aesthetics()</code>).</li>
</ul>
</div>
<div id="value-5" class="section level4">
<h4>Value</h4>
<p>Again, with our <a href="#example-plot">example plot</a>, we get:</p>
<pre><code>Error in diffStr(defaults.input, defaults.output): could not find function &quot;diffStr&quot;</code></pre>
<p>The second layer is the geom layer, and you can see how it gains defaults (e.g <code>colour</code>, <code>alpha</code>, <code>stroke</code>) as well as the <code>shape</code> aesthetic that was specified in the <code>geom_point</code> call of the <a href="#example-plot">example plot</a>.</p>
</div>
</div>
<div id="geomdraw_panel" class="section level3">
<h3>Geom$draw_panel</h3>
<p>For <code>draw_panel</code> sigs, we have</p>
<ul>
<li><code>GeomPoint</code>: <code>function(data, panel_params, coord, na.rm = FALSE)</code></li>
<li><code>GeomRect</code>: <code>function(self, data, panel_params, coord)</code></li>
<li><code>Geom</code>: <code>function(self, data, panel_params, coord, ...)</code></li>
</ul>
<p>From what I can infer from docs and source your function must accept at least three arguments. <code>draw_layer</code> from <code>Geom</code> will call <code>draw_panel</code> with three unnamed parameters that in theory should match up to <code>data</code>, <code>panel_params</code>, <code>coord</code>.</p>
<ul>
<li><code>data</code>: A data.frame with all the aesthetic values as specified via <code>aes</code>. The column names corresponding to the aesthetic names, not the original data frame column names. Additionally contains <code>PANEL</code>, <code>group</code> (set to -1 if there are no groups), and any default aesthetics specified in <code>Geom*$default_aes</code>.</li>
<li><code>panel_params</code>: named list, the intersection of parameters provided to the <code>geom_*</code> function with the formals of the <code>draw_panel</code> method, although you can customize <code>Geom</code> objects to return a specific eligible parameter list.</li>
<li><code>coord</code>: coord transformation functions?</li>
</ul>
<p>Additionally, named parameters that are the intersection of the parameters provided to the <code>geom_*</code> function by the user and the parameters of <code>draw_panel</code> are supplied.</p>
<p>Finally, since <code>draw_panel</code> is a <code>ggproto</code> method <code>self</code> will be provided if it is part of the <code>draw_panel</code> signature.</p>
<p><code>setup_data</code> is used to convert parameters / aesthetics that are not in a format amenable to plotting, to one that is. One prime example is converting <code>width</code> and <code>height</code> to <code>xmin/xmax</code> and <code>ymin/ymax</code> values.</p>
<p>In “Creating a new Geom”, <code>draw_panel</code> is described as having 3 parameters, instead of the 4 + (in particular starting with <code>self</code>) in other docs and in the source. Additionally, the <code>panel_scales</code> param appears to actually be <code>panel_params</code>, at least in the sample fun we used (but <code>?Geom</code> also references <code>panel_scales</code>).</p>
</div>
<div id="ggplot_gtable-1" class="section level3">
<h3>ggplot_gtable</h3>
<p>the user can call to provide the <code>GeomX</code> object in the plot specification step. Then <code>ggplot_build</code> (step 2) and <code>ggplot_gtable</code> will use the methods in the provided <code>ggproto</code> object to manipulate the data and produce grobs.</p>
</div>
</div>
<div id="hooks" class="section level2">
<h2>Hooks</h2>
<ol style="list-style-type: decimal">
<li>Build (<code>ggplot_build</code>): analyzes and transforms data into a format suited for translation into graphical objects:
<ol style="list-style-type: decimal">
<li>Assigns facet panels.</li>
<li>Computes aesthetic values from data and <code>aes(...)</code> specifications.</li>
<li>Assigns groups.</li>
<li>Rescales data if non linear scales are specified.</li>
<li>Computes and maps statistics.</li>
<li>Transforms special aesthetics (e.g. <code>width</code> to <code>xmin</code>-<code>xmax</code>) (Layer<span class="math inline">\(compute_geom_1 -&gt; Geom\)</span>setup_data, check_required_aesthetic)</li>
<li>Adjusts positions (e.g. dodging/stacking with <code>$compute_positions</code>). (Layer<span class="math inline">\(compute_positions -&gt; Position\)</span>setup_params/setup_data/compute_layer)</li>
<li>Recompute scales.</li>
<li>Adds default aesthetics as needed.</li>
</ol></li>
<li>Graphical Object Construction (<code>ggplot_gtable</code>):
<ol style="list-style-type: decimal">
<li>Applies coordinate transformations (if necessary)</li>
<li>Translate the data into shapes, colors, positions, etc.</li>
</ol></li>
<li>Rendering (<code>grid.draw</code>): display the resulting plot in a viewport.</li>
</ol>
<p>Need to discuss what is implemented via the <code>ggproto</code> objects.</p>
<p>Each of the sub-steps in the build step is applied to every layer before moving to the next step with the <code>by_layer</code> function. Additionally, each proto driven calculation follows this hierarchy:</p>
<p><code>(draw|compute)_layer</code> <code>(draw|compute)_panel</code> <code>(draw|compute)_group</code></p>
<p>The <code>*_layer</code> functions typically split the data by panel and forward each chunk to the corresponding <code>*_panel</code> function. The base <code>ggproto</code> <code>*_panel</code> methods will split the data by group and forward it to the corresponding <code>*_group</code> function. This allows you to override either the <code>*_panel</code> or the <code>*_group</code> function depending on what you are trying to do.</p>
</div>
<div id="understanding-the-data-object" class="section level2">
<h2>Understanding the <code>data</code> Object</h2>
<ul>
<li>Internal aesthetics</li>
<li>Special variables (<code>group</code>, <code>panel</code>)
<ul>
<li><code>group</code> are “integer” values from 1 to n where n is the number of groups, or -1 if there aren’t any groups.</li>
</ul></li>
<li>Computed variables (<code>..level..</code>)</li>
</ul>
</div>
<div id="grid-stuff" class="section level2">
<h2>Grid Stuff</h2>
<p>You cannot use <code>gList</code> in the key/legend. However, <code>grobTree</code> works.</p>
</div>
<div id="glossary" class="section level2">
<h2>Glossary</h2>
<dl>
<dt>
<a name="aesthetic"></a>Aesthetic
</dt>
<p>A variable that maps to a plot property, such as <code>x</code> position, or <code>size</code>, or <code>color</code>. <code>ggplot2</code> allows users to specify the mapping with the <code>mapping</code> argument to either the <code>ggplot</code> function or the <a href="#layer-function">layer functions</a>.</p>
After the initial specification by the user, aesthetic values are scaled, and eventually mapped to their actual display values.
<dd>
</dd>
<dt>
<a name="computed-aesthetic"></a>Aesthetic, Computed
</dt>
<dd>
<p>Aesthetic variables that are generated by <a href="#ggproto-stat"><code>Stat</code></a>. These can be referenced in the aesthetic specification by using the <code>stat</code> function (e.g. <code>aes(y=stat(count))</code>). The <code>count</code> variable does not exist in the input data, but it does exist in the data produced by the <a href="#ggproto-stat"><code>Stat</code></a>.</p>
What computed variables are available will depend on the statistic. Sometimes this is documented in the <a href="#layer-function">layer functions</a> that use those <code>Stat</code> objects (e.g. <code>?stat_bin</code>), but not always. If the variables are not documented, you can look at the most specific <a href="#stat-compute"><code>Stat$compute_*</code></a> that the <a href="#ggproto-stat"><code>Stat</code></a> defines.
</dd>
<dt>
<a name="position-aesthetic"></a>Aesthetic, Position
</dt>
<dd>
<a href="#aesthetic">Aesthetic</a> variables that correspond to position values. <code>x</code> and <code>y</code> are the most common ones, but there are many others such as <code>xmin</code>, <code>xmax</code>, <code>xend</code>.
</dd>
<dt>
<a name="ggproto"></a>Ggproto
</dt>
<dd>
<p>Object oriented framework used by <code>ggplot2</code>. See <code>?ggplot2::ggproto</code> for details. A few highlights:</p>
<ul>
<li>Objects that contain member functions and data</li>
<li>The members can be accessed like list objects <code>object$member</code></li>
<li>When member functions are invoked they are always automatically provided with a <code>self</code> object if <code>self</code> is part of the signature (you can probably still access <code>self</code> even if it isn’t in the sig, need to test).</li>
<li>You cannot debug <code>ggproto</code> methods directly because they are wrapped on the fly by <code>$.ggproto</code>. To debug, first extract the method, then <code>debug</code> it, then <code>debug</code> <code>f</code> inside of it…</li>
</ul>
</dd>
<dt>
<a name="ggproto-geom"></a>Ggproto Geom
</dt>
<dd>
<p><code>Geom*</code> <a href="#ggproto"><code>ggproto</code></a> objects such as <code>GeomPoint</code> or <code>GeomRect</code> are responsible for translating your data into graphical objects. In <code>ggplot</code> these graphical objects are called <a href="#grid-graphical-object">grobs</a>. In order to create your own geoms you will need to learn how to use <code>grid</code>, or alternatively to re-use existing <code>Geom*</code> objects to generate grobs suited for your purposes.</p>
You can extend <code>Geom</code> objects by overriding the <a href="#geom-setup-data"><code>Geom$setup_data</code></a>, <a href="#geom-setup-param"><code>Geom$setup_param</code></a>, <a href="#geom-draw-panel"><code>Geom$draw_panel</code></a>, and/or <a href="#geom-draw-group"><code>Geom$draw_group</code></a> methods. See <code>vignette(package='ggplot2', 'extending-ggplot2')</code> for examples.
</dd>
<dt>
<a name="ggproto-layer"></a>Ggproto Layer
</dt>
<dd>
<code>ggproto</code> object responsible for computing and rendering plot layers. It contains <code>Geom</code>, <code>Stat</code>, and <code>Position</code> <code>ggproto</code> sub-objects, along with other data and the methods that carry out the computation and translation of layer data into <a href="#grid-graphical-objects">grobs</a>.
</dd>
<dt>
<a name="ggproto-layout"></a>Ggproto Layout
</dt>
<dd>
<p>Contains all the metadata required to lay out the plot across the panels.</p>
<p>One particular useful method is <code>Layout$get_scales</code>, which when given a panel id will return a list with the position scales associated with that panel.</p>
The <a href="#layout-layout"><code>Layout$layout</code> member</a> is a table mapping panels to scales and positions in the overall plot.
</dd>
<dt>
<a name="ggproto-method"></a>Ggproto Method
</dt>
<dd>
<p>A function that is part of a <a href="#ggproto"><code>ggproto</code></a> object. It differs from standard R functions because of the optional <code>self</code> parameter. A <code>ggroto</code> method that has the <code>self</code> parameter will be passed the <a href="#ggproto"><code>ggproto</code></a> object the method belongs to as the value of that parameter when the it is called. This gives the method access to the object data and other methods.</p>
<p>We illustrate the use of <code>self</code> with a simple example. Neither method call provides the <code>self</code> parameter:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">Example &lt;-<span class="st"> </span><span class="kw">ggproto</span>(</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="st">&quot;Example&quot;</span>, <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="dt">method1=</span><span class="cf">function</span>(self, x) <span class="kw">cat</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%s %s</span><span class="ch">\n</span><span class="st">&quot;</span>, x, self<span class="op">$</span>secret)),</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="dt">method2=</span><span class="cf">function</span>(x) <span class="kw">cat</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%s %s</span><span class="ch">\n</span><span class="st">&quot;</span>, x, self<span class="op">$</span>secret)),</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="dt">secret=</span><span class="st">&quot;secret&quot;</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">)</a></code></pre></div>
<pre><code>Error in ggproto(&quot;Example&quot;, NULL, method1 = function(self, x) cat(sprintf(&quot;%s %s\n&quot;, : could not find function &quot;ggproto&quot;</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">Example<span class="op">$</span><span class="kw">method1</span>(<span class="st">&quot;big&quot;</span>)</a></code></pre></div>
<pre><code>Error in eval(expr, envir, enclos): object 'Example' not found</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">Example<span class="op">$</span><span class="kw">method2</span>(<span class="st">&quot;big&quot;</span>)</a></code></pre></div>
<pre><code>Error in eval(expr, envir, enclos): object 'Example' not found</code></pre>
<p><code>ggproto</code> methods are generated at call time by the <code>$</code> method for <code>ggproto</code> objects. There are several implications to this. One is that in order to see the method body you need to resort to some contortions. Here we do it for <code>GeomPoint$setup_data</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">GeomPoint<span class="op">$</span>setup_data</a></code></pre></div>
<pre><code>Error in eval(expr, envir, enclos): object 'GeomPoint' not found</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">environment</span>(GeomPoint<span class="op">$</span>setup_data)<span class="op">$</span>f</a></code></pre></div>
<pre><code>Error in environment(GeomPoint$setup_data): object 'GeomPoint' not found</code></pre>
<p>Additionally <code>debug(Object$method)</code> will not work because next time you call <code>Object$method</code> a new copy of the function is created. To <code>debug</code> <code>ggproto</code> methods you need to follow these steps:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1">fun &lt;-<span class="st"> </span>Object<span class="op">$</span>method</a></code></pre></div>
<pre><code>Error in eval(expr, envir, enclos): object 'Object' not found</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">debug</span>(<span class="kw">environment</span>(fun)<span class="op">$</span>f)</a></code></pre></div>
<pre><code>Error in environment(fun): object 'fun' not found</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">fun</span>()</a></code></pre></div>
<pre><code>Error in fun(): could not find function &quot;fun&quot;</code></pre>
Depending on circumstances it may be easier to add a <code>browser</code> call to the sources.
</dd>
<dt>
<a name="ggproto-position"></a>Ggproto Position
</dt>
<dd>
<p><code>Position*</code> <a href="#ggproto"><code>ggproto</code></a> objects such as <code>PositionDodge</code> are responsible for adjusting the position aesthetics in the layer data. For example, <code>PositionDodge</code> shifts <code>x</code> <a href="#position-aesthetic">position aesthetics</a> bins the data and computes <code>y</code> values a well as other <a href="#computed-aesthetics">computed aesthetics</a> stats such as <code>count</code> and <code>ncount</code>.</p>
You can extend <code>Position</code> objects by overriding the <a href="#position-setup-data"><code>Position$setup_data</code></a>, <a href="#position-setup-param"><code>Position$setup_param</code></a>, <a href="#position-compute-panel"><code>Position$compute_panel</code></a>, and/or <a href="#position-compute-group"><code>Position$compute_group</code></a> methods. See the sources for <code>Position</code> objects for examples.
</dd>
<dt>
<a name="ggproto-stat"></a>Ggproto Stat
</dt>
<dd>
<p><code>Stat*</code> <a href="#ggproto"><code>ggproto</code></a> objects such as <code>StatBin</code> are responsible for recomputing the plot data with a statistic and potentially adding new variables. For example, <code>StatBin</code> bins the data and computes <code>y</code> values as well as other stats such as <code>count</code> and <code>ncount</code>.</p>
You can extend <code>Stat</code> objects by overriding the <a href="#stat-setup-data"><code>Stat$setup_data</code></a>, <a href="#stat-setup-param"><code>Stat$setup_param</code></a>, <a href="#stat-compute-panel"><code>Stat$compute_panel</code></a>, and/or <a href="#stat-compute-group"><code>Stat$compute_group</code></a> methods. See <code>vignette(package='ggplot2', 'extending-ggplot2')</code> for examples.
</dd>
<dt>
<a name="grid">Grid
</dt>
<dd>
Low level graphics package that comes packaged by default with R. It is used by <code>ggplot</code> to draw the plots. There are several useful vignettes you can find with <code>browseVignettes('grid')</code>.
</dd>
<dt>
<a name="grid-graphical-object">Grid Graphical Objects
</dt>
<dd>
A.k.a. grobs, R objects that contain description of graphical elements that can be used by the <code>grid</code> package to draw them on a graphical device.
</dd>
<dt>
<a name="layer-function"></a>Layer Function
</dt>
<dd>
<p>Functions that create <a href="#ggproto-layer"><code>Layer</code> <code>ggproto</code></a>) objects like <code>geom_point</code> or <code>stat_bin</code>. For example, in (a simplified version of) <code>geom_point</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1">geom_point &lt;-<span class="st"> </span><span class="cf">function</span>(</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  <span class="dt">mapping =</span> <span class="ot">NULL</span>, <span class="dt">data =</span> <span class="ot">NULL</span>, <span class="dt">stat =</span> <span class="st">&quot;identity&quot;</span>, <span class="dt">position =</span> <span class="st">&quot;identity&quot;</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">)</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  <span class="kw">layer</span>(</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    <span class="dt">data =</span> data, <span class="dt">mapping =</span> mapping, <span class="dt">stat =</span> stat, <span class="dt">geom =</span> GeomPoint,</a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    <span class="dt">position =</span> position,</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  )</a></code></pre></div>
<p>The layer function calls <code>ggplot2::layer</code>. This function expands shortcut names for <a href="#ggproto"><code>ggproto</code> objects</a> into the corresponding <code>ggproto</code> objects. In <code>geom_point(position='jitter', size=2)</code> it translates the <code>'jitter'</code> string into a <code>PositionJitter</code> <code>ggproto</code> object, and implicitly due to the default value for <code>stat</code> parameter it also translates the string <code>'identity'</code> into the <code>StatIdentity</code> <code>ggproto</code> object.</p>
<p>These functions will allocate their parameters to the various subcomponents of the <a href="#ggproto-layer"><code>Layer</code> <code>ggproto</code></a>) object such as the <a href="#ggproto-stat"><code>Stat</code></a>, <a href="#ggproto-geom"><code>Geom</code></a>, or alternatively to the aesthetic mapping specification.</p>
<p>Parameter matching is typically done by looking at the parameters for the corresponding <code>ggproto</code> <code>$compute/draw_panel</code> methods, and if that method contains <code>...</code> in the signature, also by looking at the parameters of the <code>ggproto</code> <code>$compute/draw_group</code> methods. For example, for <code>StatBin</code> we have:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">args</span>(<span class="kw">environment</span>(StatBin<span class="op">$</span>compute_panel)<span class="op">$</span>f)</a></code></pre></div>
<pre><code>Error in environment(StatBin$compute_panel): object 'StatBin' not found</code></pre>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">args</span>(<span class="kw">environment</span>(StatBin<span class="op">$</span>compute_group)<span class="op">$</span>f)</a></code></pre></div>
<pre><code>Error in environment(StatBin$compute_group): object 'StatBin' not found</code></pre>
<p>Note: the <code>args(environment(...)$f)</code> business is required because <a href="ggproto-methods"><code>ggproto</code> methods</a> are not directly accessible.</p>
Since <code>StatBin$compute_panel</code> has a <code>...</code> parameter, layer functions with <code>StatBin</code> as the stat will match their parameters against the union of the parameter list for <code>$compute_panel</code> and <code>$compute_group</code>. So in the call <code>stat_bin(bins=10)</code> the layer function <code>stat_bin</code> will match the parameter <code>bin</code> to the <code>$compute_group</code> parameters, and as a result store that parameter in the <code>StatBin$parameters</code> list. This parameter list can then be used by other <code>StatBin</code> methods such as <a href="#stat-compute"><code>StatBin$compute_group</code></a>.
</dd>
<dt>
<a name="ggproto-scale"></a>Scale, Ggproto
</dt>
<dd>
<p>Contains meta data about the scales (e.g. the range) and methods to transform the data.</p>
<p>For example, <code>scale_x_sqrt</code> produces a <code>ScaleContinuous</code> <code>ggproto</code> object with a <code>$trans</code> method that will covert any <code>x</code> related aesthetics to their square roots.</p>
There are is also typically the <code>$map</code> to map the aesthetics into the display space (e.g. categories into colors), although for <a href="#position-aesthetic">position aesthetics</a> that is typically handled by <code>Coord$transform</code> <strong>This needs to be confirmed</strong>.
</dd>
<dt>
<a name="ggproto-scale-position"></a>Scale, Position, Ggproto
</dt>
<dd>
<a href="#ggproto-scale">Scales</a> that correspond to the <a href="#position-aesthetic">position aesthetics</a>.
</dd>
</dl>
<dt>
<a name="scale-map"></a>Scale, Map
</dt>
<dd>
Use scales to convert aesthetic values into the space they will be plotted in. For example, values on a color/fill scale are converted to the colors they will be displayed as. Mapping for <a href="#ggproto-scale-position">position scales</a> would in theory convert values into the 0-1 range, but that is actually handled by the coordinate transformation instead.
</dd>
</dl>
<dt>
<a name="scale-train"></a>Scale, Train
</dt>
<dd>
<p>Process that computes the range of values covered by a scale. For continuous scales this is typically just the min and max values, whereas for discrete scales it is the sorted unique listing of all the different values.</p>
Typically <a href="#ggproto-scale-position">position scales</a> are trained several times in the plot build process as they are used therein and the data is changed, e.g. via statistics or position adjustments.
</dd>
</dl>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
