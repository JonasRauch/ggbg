---
title: "Gggplot2 Internals - An Unofficial Reference"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css:
          - !expr file.path(system.file(package="diffobj"),"css","diffobj.css")
          - styles.css
vignette: >
  %\VignetteIndexEntry{extensions}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
options(
  digits=2, diffobj.pager="off", crayon.enabled=TRUE,
  # diffobj.format="ansi256", diffobj.brightness="light",
  diffobj.format="html", diffobj.disp.width=120,
  diffobj.ignore.white.space=TRUE
)
sgr_wrap <- function(x, options){
  paste0(
    "<pre class=\"r-output\"><code>",
    fansi::sgr_to_html(x = htmltools::htmlEscape(x)),
    "</code></pre>"
  )
}
# knitr::knit_hooks$set(output=sgr_wrap)
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(ggbg)
```

*DRAFT*

## Introduction

This document is an unofficial reference for developers looking to extend
`ggplot2`.  It supplements to existing documentation by providing more
detail about how the extension mechanism interacts with other parts of the
`ggplot2` plot building process.  It is based on examination of the sources of
`ggplot2` circa 5/2018 (version 2.3 pre-release), and may become out of date as
`ggplot2` evolves.

We assume the reader is familiar with using `ggplot2` for generating plots, and
that the reader has previously reviewed:

* `?ggproto` for an introduction to the `ggplot2` object oriented programming
  system.
* `?ggplot2::ggplot2-ggproto` for the major `ggproto` objects used by `ggplot2`.
* `vignette(package='ggplot2', 'extending-ggplot2')` for the official
  documentation on extending `ggplot2`.

There are four major sections to this document:

1. Overview: A high level look at the process of converting data and user
   `ggplot2` plot specifications into a plot.
2. Process Outline: The listing of all the key function calls used by `ggplot2`
   to generate the plot.  This gives you a sense for where your extension fits
   in relation to the rest of the process.  Most steps in the outline are
   hyperlinked to the "Process Detail" section.
3. Process Detail: More detail on the important steps in the plot generation
   process, including descriptions of inputs, outputs, and other relevant
   information for anyone looking to modify those steps.
4. Definitions: Definitions of key terms.  These are hyperlinked throughout the
   document.

## Overview

### It's All in the Printing

Four major steps are required to produce a `ggplot`:

1. Specification: user specifies what the plot should look like with
   `ggplot(...) + geom_*(...)`, etc..
2. Build: `ggplot2` manipulates the data as directed by the user plot
   specification (e.g. applies stats, position adjustments, scale
   transformation, mapping to [aesthetics](#aesthetic) etc).
3. Graphical Object Creation: `ggplot2` translates the data into [`grid`](#grid)
   [graphical objects (grobs)](#grob).
4. Render: display the graphical objects on a graphics device.

Step 1 is done directly by the user and will be familiar to all `ggplot2` users.
Steps 2-4 are triggered by the printing of a `ggplot2` object, as shown by this
simplified version of `print.ggplot`:

```{r eval=FALSE}
print.ggplot <- function (x, ...) {
  data <- ggplot_build(x)        # step 2: build
  gtable <- ggplot_gtable(data)  # step 3: create grobs
  grid.draw(gtable)              # step 4: render
}
```
Almost all the work `ggplot2` does is in these last three steps.  In order to
successfully extend `ggplot2` it helps to understand what happens in them,
particularly the `ggplot_build` and `ggplot_gtable` steps.  This documents
breaks down what happens in those two steps.

### Extension Mechanism

Before we get into the nitty-gritty of `ggplot_build` and `ggplot_gtable`, we
need to review the `ggplot2` extension mechanism.  This extension mechanism
allows us to add new `geom_*`, `stat_*`, or even almost any `ggplot2`
functionality.

`ggplot2` is extended by defining [`ggproto` objects](#ggproto) that inherit
from the existing [`Geom`](#ggproto-geom), [`Stat`](#ggproto-geom),
[`Position`](#ggproto-geom), [`Scale`](#ggproto-scale), `Coord`, `Facet`, and
other `ggproto` objects.  `ggproto` objects contain both data and functions
(a.k.a.  [methods](#ggproto-method)).  This allows us to override existing
functionality by providing `ggproto` objects with custom
[methods](#ggproto-method).

If we want to define a new `Geom` "x", we create a `GeomX` `ggproto` object that
extends `Geom` and modifies the relevant methods.  We then provide a
corresponding [layer function](#layer-function) that associates it with a
[`Layer` `ggproto` object](#ggproto-layer) that can be added to the `ggplot`.

For examples on how to do this see `vignette(package='ggplot2',
'extending-ggplot2')`.

### Plot Structure

A `ggplot` is a nested structure of [`ggproto`](#ggproto) and other objects.
This is a simplified version of the structure:

```
plot (list)
+ data (data.frame)
+ Coord (ggproto)
+ Facet (ggproto)
+ Scales (ggproto) can contain multiple Scale objects
  + Scale (ggproto)
+ layers (list) can contain multiple Layer objects
  + Layer (ggproto)
    + data (data.frame)
    + Geom (ggproto)
    + Stat (ggproto)
    + Position (ggproto)
```

The portion of the structure you are most likely to interact with when extending
`ggplot2` is the `Layer` object and its sub-objects.  Within that there is an
additional level of implicit structure. The [`ggplot_build`](#ggplot-build)
process adds [`PANEL`](#panel) and `group` variables to the `Layer$data`
`data.frame`.  This creates groups of rows that each correspond to a particular
[panel](#panel) or group within that [panel](#panel).

## Method Outline

### ggplot_build

`ggplot_build` starts with the input data and the plot specification.  It then
proceeds through several steps that sequentially transform the data by adding
and/or recomputing variables, or in the case of statistics recomputing the
entire data.  In addition to transforming the data, the build process also
updates and computes meta data for scales, facets, etc.  The work is carried out
by the methods of [`ggproto` objects](#ggproto) provided implicitly via the plot
specification.

A simplified outline of the methods called by `ggplot_build` follows.  This is
not comprehensive and hides some of the logic.  For example, some methods are
called for every layer, or every panel, and that is not shown here.  This
outline is intended to give a rough idea of what happens in what order.  It also
acts as an index to more comprehensive documentation for the key methods.
Almost all methods you would override when extending `ggplot2` should be listed
here so you can search for them.  For example, if you are creating a new `Geom`,
search for "Geom" in the index below.  For context, we include calls to methods
for the `Layer`, `Layout`, `Facet`, and `Coord` objects even though you are less
likely to modify them.

* [`Layer$layer_data`](#layerlayer_data): assign data to each layer.
* `Layout$setup`:
    * [`Facet$setup_params`](#setup_params-setup_data): unused by common `Facet`
      objects.
    * [`Facet$setup_data`](#setup_params-setup_data): unused by common `Facet`
      objects.
    * [`Coord$setup_data`](#setup_params-setup_data): unused by common `Coord`
      objects.
    * [`Facet$compute_layout`](#facetcompute_layout): generate facet meta data.
    * `Coord$setup_layout`:
    * [`Facet$map_data`](#facetmap-data): add the `PANEL` variable that maps
      data rows to facets.
* [`Layer$compute_aesthetics`](#layercompute_aesthetics): compute aesthetics,
  add `group` variable.
* [`Scale$transform_df`](#scaletransform_df): apply scale transformations to
  aesthetics.
* `Layout$train_position`: initialize and [train](#train-scale) position
  scales.
* [`Layout$map_position`](#layoutmap_position): [map](#map-scale) [position
  scales](#position-scale).
* `Layer$compute_statistic`: recompute data with statistics.
    * [`Stat$setup_params`](#setup_params-setup_data): adjust parameters.
    * [`Stat$setup_data`](#setup_params-setup_data): adjust data.
    * [`Stat$compute_layer`](#stat-compute): apply statistic to each layer.
    * [`Stat$compute_panel`](#stat-compute): apply statistic to each panel.
    * [`Stat$compute_group`](#stat-compute): apply statistic to each group.
* `Layer$map_statistic`: re-computes and rescales aesthetics using the data
  produced by [`Stat$compute_layer`](#stat-compute).
* `scales_add_missing`: adds default scales for the layer for the `x` and `y`
  aesthetics if they are part of the layer specification and are missing.
* `Layer$compute_geom_1`: prepare `Geom` data for each layer.
    * [`Geom$setup_data`](#setup_params-setup_data): adjust data.
    * `check_required_aesthetics`.
* `Layer$compute_position`: apply position adjustments.
    * [`Position$setup_params`](#setup_params-setup_data): adjust parameters.
    * [`Position$setup_data`](#setup_params-setup_data): adjust data.
    * [`Position$compute_layer`](#positioncompute_layer): adjust positions for
      layer.
    * [`Position$compute_panel`](#positioncompute_panel): adjust positions for
      panel.
* `Layout$reset_scales`: remove any previous [scale training](#scale-train).
* `Layout$train_position`: [re-train](#scale-train) the [position
  scales](#ggproto-position-scale).
* [`Layout$setup_panel_params`](#layoutsetup_panel_params): compute meta-data
  for panels.
* [`Layout$map_position`](#layoutmap_position): re-map [position
  scales](#ggproto-position-scale).
* [`scales_train_df`](#train-map-scale): [train](#train-scale)
  non-[position scales](#position-scales).
* [`scales_map_df`](#train-map-scale): [map](#map-scale)
  non-[position scales](#position-scales).
* `Layer$compute_geom_2`: add defaults and aesthetic parameters.
    * [`Geom$use_defaults`](#geom-use_defaults).
* `Layer$finish_statistics`:
    * `Stat$finish_layer`: typically unused, gives stat one more chance to
      modify data after it is [mapped](#map-scale).
* `Layout$finish_data`:
    * `Facet$finish_data`: typically unused, gives `Facet` one last chance to
      modify data with access to the [layout](#layoutlayout) meta data and the
      position scales.

### ggplot_gtable

TBD.

## Method Details

### Example Plot

We illustrate inputs and outputs to some of the methods documented in this
section with the following plot:

```{r, eval=FALSE}
dat <- data.frame(
  loc=(1:4)^2,
  val=(5:8)^2,
  grp=c('A', 'B', 'B', 'C'),
  pnl=c('P1', 'P1', 'P2', 'P2')
)
library(ggplot2)
p <- ggplot(dat, aes(x=loc, y=val, fill=grp)) +
  stat_bin2d() +
  geom_point(position="jitter", shape=21) +
  facet_wrap(~pnl, scales="free_x") +
  scale_x_sqrt() +
  scale_y_sqrt()
```

It involves a standard layer, a statistic layer, it has facets, and it scales
the [position aesthetics](#position-aesthetic).

### Layer$layer_data

For each layer, this method assigns the data to be used, which is either the
data specified in the `geom_*` / `stat_*` [layer function](#layer-function) call
if any, or if not the data specified in the `ggplot()` call.  Because neither
layer in the [example plot](#example-plot) had data they both acquire the plot
data.

### Object\$setup_params And Object\$setup_data {#setup_params-setup_data}

#### Description

`ggplot2` has a complex plot specification system.  In most cases, the users
typed commands are relatively simple, but `ggplot2` then needs to set or
compute default values for derived variables and parameters.  To assist with
this most of the [`ggproto` objects](#ggproto) have `$setup_params` and
`$setup_data` methods.  These are often called after some of the initial setup
has been done (e.g. [assigning layer data](#layerlayer_data)) so that they can
use this information to update the data or parameters.

For example, `Facet$setup_params` is called with a list containing the plot data
and the data for every layer after the data is associated to each layer.  This
gives the method the opportunity to update the parameters in the context of the
entirety of the data.

The `$setup_data` methods provide an opportunity to update the data, also after
the data has been assigned to layers, and after the parameters have been updated
with the `$setup_params` methods. An example is how some `Geoms` will add `xmin`
and `xmax` aesthetics computed from existing `x` and `width` aesthetics with the
`$setup_data` method.

#### Signature

`$setup_params([self], data, params)`<br />
`$setup_data([self], data, params)`

The `self` parameter, if present, can appear anywhere in the signature.  The
other two parameters must be in the relative order shown above.

#### Parameters

* `self`: optional parameter, if present will point to the `ggproto` object the
  method belongs to.
* `data`: the layer data.  Depending on which `ggproto` object the `$setup_*`
  method belongs to it may have undergone scale transformation and/or mapping.
  See the [method outline](#method-outline) to get an idea of the state of the
  data by the time it gets to the `$setup_*` method in question.
* `params`: a list of the parameters provided to the [layer
  function](#layer-function) that match the parameters of the
  `$[compute|draw]_panel` of `self`, and if that method has a `...` parameter,
  then also the parameters of the `$[compute|draw]_group` method.

#### Value

For `$setup_params`, a list of the parameters associated with the corresponding
[`ggproto`](#ggproto) object.

For `$setup_data`, the updated data.

#### See Also

Some of the default methods are documented in `?'ggplot2-ggproto'`.  The
definition of [ggproto methods](#ggproto-method) for details about the `self`
parameter, [layer functions](#layer-function) for details about how the `params`
list is generated.

### Facet$compute_layout

Assigns a panel, row, column, and position scale ids to each facet.  It is
possible to have multiple position scales in a plot when the scales are "free".

This data is stored in the `$layout` <a name='layout-layout'></a> member of the
[`Layout` `ggproto`](#ggproto-layout) object.  This is what it looks like for
our [example plot](#example-plot):

```
  PANEL ROW COL pnl SCALE_X SCALE_Y
1     1   1   1  P1       1       1
2     2   1   2  P2       2       1
```

Our data has two facets (panels) arranged across two columns and in one row.
There is one `y` scale, and two `x` scales because with set "free_x" in the
facet specification for the plot.

### Facet$map_data

For each layer, add the `PANEL` variable to the data.  Here we show the effect
it has on the data of the first layer of our [example plot](#example-plot):

```{r, echo=FALSE, results="asis"}
input <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor")), .Names = c("loc", "val", "grp",
"pnl"), row.names = c(NA, -4L), class = "data.frame")
output <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor"), PANEL = structure(c(1L, 1L, 2L,
    2L), .Label = c("1", "2"), class = "factor")), .Names = c("loc",
"val", "grp", "pnl", "PANEL"), row.names = c(NA, 4L), class = "data.frame")
diffobj::diffPrint(input, output)
```

### Layer$compute_aesthetics

For each layer, evaluates all the [mapped aesthetic](mapped-aesthetics)
`aes(...)` expressions and replace the data variables with the resulting
aesthetics.  [Stat aesthetics](#stat-aesthetic) are evaluated later as part of
the [stat computation](#stat-compute) process.

This step also infers the `group` aesthetic from the interaction of categorical
[mapped aesthetics](#mapped-aesthetic).

Here we show the effect on one of the layer's data:

```{r, echo=FALSE, results="asis"}
input <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor"), PANEL = structure(c(1L, 1L, 2L,
    2L), .Label = c("1", "2"), class = "factor")), .Names = c("loc",
"val", "grp", "pnl", "PANEL"), row.names = c(NA, 4L), class = "data.frame")
output <- structure(list(x = c(1, 4, 9, 16), y = c(25, 36, 49, 64), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), row.names = c(NA, -4L), class = "data.frame")
diffobj::diffPrint(input, output)
```

The variable have changed to be the aesthetics, and we gain the `group`
variable.

### Scale$transform_df

This is applies scale transformations to each layer.  In our example, we use
`scale_*_sqrt`.  Here is the effect on the data for one of the layers:

```{r, echo=FALSE, results="asis"}
trans.input <- structure(list(x = c(1, 4, 9, 16), y = c(25, 36, 49, 64), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), row.names = c(NA, -4L), class = "data.frame")
trans.output <- structure(list(x = c(1, 2, 3, 4), y = c(5, 6, 7, 8), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), class = "data.frame", row.names = c(NA, -4L))
diffobj::diffPrint(trans.input, trans.output)
```

The transformation is applied by calling `Scale$transform` on all the aesthetics
that are associated with the scale.  You can check which aesthetics are
associated with a stat with the `$aesthetics` member of the stat:

```{r}
scale <- scale_x_continous()
scale
scale$aesthetics
```

### Layout$map_position

For each layer, [map](#ggproto-scale-map) data with [position
scales](#position-scale).

For continuous variables this in theory would rescale the continuous position
aesthetics (e.g. `x`, `xmin`, `xmax`, `y`, etc.) into the display range (e.g.
0-1), but because "the coordinate system takes care of it" the only thing this
does is handle NAs and convert integer aesthetics to numeric.

Discrete variables are mapped onto integers for each value.  This only happens
once even though the build process calls `Layout$map_position` twice.  The
second time it will only be applied to aesthetics that have not already been
converted (e.g those added by a `stat`).

### Stat$compute_layer/panel/group {#stat-compute}

#### Description

These methods are responsible for applying a statistic to the layer data and
returning the result as the new layer data.  Typically you would modify one of
the layer, panel, or group methods, listed here in order of increasing
specificity.  If possible, you should modify the most specific method (e.g. the
group method) as that requires the least work.  If you need more control over
the process you can override on of the more general methods.  If you do this,
for example by overriding the panel method, you will be responsible for
splitting the data into groups, processing the groups, and re-assembling the
data.

`$compute_layer` is called on each layer of the plot.  The default layer and
panel method respectively run the panel and group methods over each panel and
group.  This is why you can just override the more specific methods.

#### Signature

`$compute_layer([self], data, params, layout)`
`$compute_panel([self], data, scales, ...)`
`$compute_group([self], data, scales)`

#### Parameters

* `self`: optional parameter, if present will point to the `Stat` `ggproto`
  object the method belongs to.
* `data`: the layer data for `$compute_layer`, a subset of the layer data
  corresponding to a panel for `$compute_panel`, or a subset of the panel data
  corresponding to a group for `$compute_group`.
* `params`: the parameter list as matched to the `$compute_panel/group` methods
  by the [layer function](#layer-function).
* `layout`: the [`Layout` `ggproto`](#ggproto-layout) object for the plot,
  provided mostly so that `$compute_layer` can extract the position scales to
  pass on to `$compute_panel` and `$compute_group`.
* `scales`: a list with the position scales for the panel.  This can be useful
  if values in `params` need to be transformed by the scales (e.g. breaks that
  correspond to `x` values).  `scales[['x']]` contains the `x` scale, and
  `scales[['y']]` contains the `y` scale.

#### Value

Statistics can completely change the data.  Here is what the input to
`Stat$compute_layer` looks like in [example plot](#example-plot):

```{r echo=FALSE}
stat.input <- trans.output
stat.input
```

And if you have not modified the layer method, then the input into
`Stat$compute_panel` will look like (for the first panel):

```{r echo=FALSE}
structure(list(x = c(1, 2), y = c(5, 6), fill = structure(1:2, .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L, 1L), .Label = c("1", "2"), class = "factor"), group = 1:2), .Names = c("x", "y", "fill", "PANEL", "group"), class = "data.frame", row.names = c(NA, -2L), vars = "PANEL")
```

And if you have not modified the panel method, the input into `Stat$group_panel`
will look like (for the first group of the first panel):

```{r echo=FALSE}
structure(list(x = 1, y = 5, fill = structure(1L, .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(1L, .Label = c("1", "2"), class = "factor"), group = 1L), .Names = c("x", "y", "fill", "PANEL", "group"), vars = "PANEL", row.names = 1L, class = "data.frame")
```

In the [example plot](#example-plot) `StatBin2d` overrides the `$compute_group`
method.  The result for the first group of the first panel is then:

```{r echo=FALSE}
structure(list(xbin = 1L, ybin = 1L, value = 1, x = 1.01666666666667, width = 0.0333333400000002, y = 5.05, height = 0.10000002, count = 1, density = 1), .Names = c("xbin", "ybin", "value", "x", "width", "y", "height", "count", "density"), row.names = 1L, class = "data.frame")
```

If you only override the `$compute_group` method, `$compute_panel` will add back
any variables that are lost by `$compute_group`, although it does so by
recycling the first values of those variables.  In this case `$compute_panel`
adds back the `fill`, `PANEL`, and `group` variables that were dropped by
`$compute_group`.

The final output after `$compute_panel` and `$compute_layer` stitch back the
groups and panels together:

```{r echo=FALSE}
stat.ouptput <- structure(list(xbin = c(1L, 30L, 1L, 30L), ybin = c(1L, 10L, 20L, 30L), value = c(1, 1, 1, 1), x = c(1.01666666666667, 1.98333333666667, 3.01666666666667, 3.98333333666667), width = c(0.0333333400000002, 0.033333333333333, 0.0333333399999995, 0.0333333333333337), y = c(5.05, 5.95000001, 6.95000001, 7.95000001), height = c(0.10000002, 0.0999999999999996, 0.0999999999999996, 0.100000000000001), count = c(1, 1, 1, 1), density = c(1, 1, 1, 1), fill = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B",
"C"), class = "factor"), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = c(1L, 2L, 2L, 3L)), .Names = c("xbin", "ybin", "value", "x", "width", "y", "height", "count", "density", "fill", "PANEL", "group"), row.names = c(NA, -4L), class = "data.frame")
stat.output
```

If we compare to the input to `$compute_layer` we can see that several variables
(the [stat aesthetics](#stat-aesthetic)) were added to the data:

```{r echo=FALSE, results="asis"}
diffobj::diffStr(stat.input, stat.output)
```

In this case the number of rows in input and output happens to be the same
because each of our groups only has one row in it, but that is not a
requirement.

Ultimately, this step should produce data that once processed by
[`Layer$map_statistic`](#layer-map_statistic) has all the required aesthetics
required by the [`Geom`](ggproto-geom) associated with the layer.

### Layer$map_statistic

#### Description

Since [`Stat$compute_layer`](#stat-compute) creates new data, we need to
re-apply some of the early computations and transformations on the aesthetics.
`$map_statistic` effectively applies the following to our stat-recomputed data:

* [`Layer$compute_aesthetic`](#layer-compute-aesthetic) (kind of).
* [`Scales$transform_df`](#scales-transform-df).

`$map_statistic` does not actually call `$compute_aesthetic`, but it does most
of what `$compute_aesthetic` does.  There are differences, for example
this [computed aesthetics](#comupted-aesthetic) are evaluated, whereas they are
not by `$compute_aesthetic`.

#### Signature

`$map_statistic([self], data, plot)`

#### Parameters

* `self`: optional parameter, if present will point to the `Stat` `ggproto`
  object the method belongs to.
* `data`: the data for a layer after the statistic has been applied.
* `plot`: the `Plot` `ggproto` object.

#### Value

The data, with [computed](#stat-aesthetic) and other aesthetics specified by
the stat [layer function](#layer-function) that were dropped by the statistic
added back.

### Position$compute_layer/panel {#position-compute}

#### Description

These methods adjust [position aesthetics](#position-aesthetic) in the data for
groups of elements that are considered to overlap.  For example,
both `position_dodge` and `position_stack` group data by `xmin` aesthetic value
(either user provided, or derived from `x` and `width` or some such), and then
resolve any `xmin` overlaps by allocating the available width for each distinct
`group` within, or modifying `ymin` / `ymax` values so elements will stack.

`$compute_layer` is called on each layer of the plot, and the default method
then calls `$compute_panel` on each panel in the layer.  Unlike with the [stat
computation](#stat-compute) methods there is not a default `$compute_group`
method since typically the position adjustment must be made accounting for all
the groups positions simultaneously.

#### Signature

`$compute_layer([self], data, params, layout)`
`$compute_panel([self], data, params, scale)`

#### Parameters

* `self`: optional parameter, if present will point to the `Stat` `ggproto`
  object the method belongs to.
* `data`: the layer data for `$compute_layer`, a subset of the layer data
  corresponding to a panel for `$compute_panel`.
* `params`: the parameter list as matched to the `$compute_panel/group` methods
  by the [layer function](#layer-function).
* `layout`: the [`Layout` `ggproto`](#ggproto-layout) object for the plot,
  provided mostly so that `$compute_layer` can extract the position scales to
  pass on to `$compute_panel` and `$compute_group`.
* `scales`: a list with the position scales for the panel.  This can be useful
  if values in `params` need to be transformed by the scales (e.g. breaks that
  correspond to `x` values).  `scales[['x']]` contains the `x` scale, and
  `scales[['y']]` contains the `y` scale.

#### Value

The data with positions adjusted.  Here is how `$compute_layer` changes the
input data in our [example plot](#example-plot) that uses `position_jitter`:

```{r, echo=FALSE, results="asis"}
pos.input <- structure(list(x = c(1, 2, 3, 4), y = c(5, 6, 7, 8), fill = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L, 2L, 2L, 3L), n = 3L)), row.names = c(NA, -4L), class = "data.frame")
pos.output <- structure(list(x = c(0.909038454852998, 2.01686128247529, 3.11151186432689, 3.61253762301058), y = c(5.05882231164724, 6.13020793590695, 7.29328686017543, 8.22853694036603), fill = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L, 2L, 2L, 3L), n = 3L)), row.names = c(NA, -4L), class = "data.frame")
diffobj::diffPrint(pos.input, pos.output)
```

This adjust the `x` and `y` aesthetics, though it would also adjust any other
[position aesthetics](#position-aesthetic) if they existed in the data.

If you overrode the `$compute_panel` method instead of `$compute_layer` as
`position_jitter` does, each input and output should be the same, except subset
by the `PANEL` variable.

### Layout$setup_panel_params

Generates a list that, for each panel, contains a list of the key meta data for
the [position scales](#position-scale), including the range, labels, location of
major and minor breaks, and axis order, amongst others.  The list is then stored
in `Layout$panel_params`, by reference.  Here is what this list looks like in
our [example plot](#example-plot):

```
List of 2
 $ :List of 14
  ..$ x.range       : num [1:2] 0.576 2.438
  ..$ x.labels      : chr [1:5] "1" "2" "3" "4" ...
  ..$ x.major       : num [1:5] 0.228 0.45 0.621 0.765 0.892
  ..$ x.minor       : num [1:11] 0.0055 0.1167 0.2279 0.3391 0.4503 ...
  ..$ x.major_source: num [1:5] 1 1.41 1.73 2 2.24
  ..$ x.minor_source: num [1:11] 0.586 0.793 1 1.207 1.414 ...
  ..$ x.arrange     : chr [1:2] "secondary" "primary"
  ..$ y.range       : num [1:2] 4.81 8.41
  ..$ y.labels      : chr [1:5] "30" "40" "50" "60" ...
  ..$ y.major       : num [1:5] 0.185 0.42 0.627 0.815 0.987
  ..$ y.minor       : num [1:10] 0.0675 0.185 0.3026 0.4202 0.5238 ...
  ..$ y.major_source: num [1:5] 5.48 6.32 7.07 7.75 8.37
  ..$ y.minor_source: num [1:10] 5.05 5.48 5.9 6.32 6.7 ...
  ..$ y.arrange     : chr [1:2] "primary" "secondary"
 $ :List of 14
  ..$ x.range       : num [1:2] 2.95 4.05
  ..$ x.labels      : chr [1:4] "10" "12" "14" "16"
  ..$ x.major       : num [1:4] 0.193 0.467 0.72 0.955
  ..$ x.minor       : num [1:8] 0.0558 0.193 0.3302 0.4674 0.5935 ...
  ..$ x.major_source: num [1:4] 3.16 3.46 3.74 4
  ..$ x.minor_source: num [1:8] 3.01 3.16 3.31 3.46 3.6 ...
  ..$ x.arrange     : chr [1:2] "secondary" "primary"
  ..$ y.range       : num [1:2] 4.81 8.41
  ..$ y.labels      : chr [1:5] "30" "40" "50" "60" ...
  ..$ y.major       : num [1:5] 0.185 0.42 0.627 0.815 0.987
  ..$ y.minor       : num [1:10] 0.0675 0.185 0.3026 0.4202 0.5238 ...
  ..$ y.major_source: num [1:5] 5.48 6.32 7.07 7.75 8.37
  ..$ y.minor_source: num [1:10] 5.05 5.48 5.9 6.32 6.7 ...
  ..$ y.arrange     : chr [1:2] "primary" "secondary"
```

### Train/Map Scales {#train-map-scale}

#### Description

`scales_train_df` runs the [scale training](#train-scale) on every aesthetic
corresponding to the provided scales (non-position scales in `ggplot_build`)
across every layer.

`scales_map_df` [maps](#map-scale) every aesthetic corresponding to the
provided scales (non-position scales in `ggplot_build`) across every layer.

#### Value

`scales_train_df` only update the scale meta data.  `scales_map_df` will modify
the data, as in our [example plot](#example-plot):

```{r, echo=FALSE, results="asis"}
map.scale.input <- list(structure(list(xbin = c(1L, 30L, 1L, 30L), ybin = c(1L, 10L, 20L, 30L), value = c(1, 1, 1, 1), x = c(1.01666666666667, 1.98333333666667, 3.01666666666667, 3.98333333666667), y = c(5.05, 5.95000001, 6.95000001, 7.95000001), count = c(1, 1, 1, 1), density = c(1, 1, 1, 1), fill = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = c(1L, 2L, 2L, 3L), xmin = c(0.999999996666667, 1.96666667, 2.99999999666667, 3.96666667), xmax = c(1.03333333666667, 2.00000000333333, 3.03333333666667, 4.00000000333333), ymin = c(4.99999999, 5.90000001, 6.90000001, 7.90000001), ymax = c(5.10000001, 6.00000001, 7.00000001, 8.00000001)), .Names = c("xbin", "ybin", "value", "x", "y", "count", "density", "fill", "PANEL", "group", "xmin", "xmax", "ymin", "ymax"), row.names = c(NA, -4L), class = "data.frame"), structure(list(x = c(0.802855186536908, 2.15149602368474, 3.06846169922501, 4.36551264487207), y = c(4.76531683262438, 6.03128328304738, 6.72641851641238, 8.20721130892634), fill = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L, 2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL", "group"), row.names = c(NA, -4L), class = "data.frame"))
map.scale.output <- list(structure(list(fill = c("#F8766D", "#00BA38", "#00BA38", "#619CFF"), xbin = c(1L, 30L, 1L, 30L), ybin = c(1L, 10L, 20L, 30L), value = c(1, 1, 1, 1), x = c(1.01666666666667, 1.98333333666667, 3.01666666666667, 3.98333333666667), y = c(5.05, 5.95000001, 6.95000001, 7.95000001), count = c(1, 1, 1, 1), density = c(1, 1, 1, 1), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = c(1L, 2L, 2L, 3L), xmin = c(0.999999996666667, 1.96666667, 2.99999999666667, 3.96666667), xmax = c(1.03333333666667, 2.00000000333333, 3.03333333666667, 4.00000000333333), ymin = c(4.99999999, 5.90000001, 6.90000001, 7.90000001), ymax = c(5.10000001, 6.00000001, 7.00000001, 8.00000001)), .Names = c("fill", "xbin", "ybin", "value", "x", "y", "count", "density", "PANEL", "group", "xmin", "xmax", "ymin", "ymax"), class = "data.frame", row.names = c(NA, -4L)), structure(list(fill = c("#F8766D", "#00BA38", "#00BA38", "#619CFF"), x = c(0.802855186536908, 2.15149602368474, 3.06846169922501, 4.36551264487207), y = c(4.76531683262438, 6.03128328304738, 6.72641851641238, 8.20721130892634), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L, 2L, 2L, 3L), n = 3L)), .Names = c("fill", "x", "y", "PANEL", "group"), class = "data.frame", row.names = c(NA, -4L)))

map.scale.output[[1]] <- map.scale.output[[1]][names(map.scale.input[[1]])]
map.scale.output[[2]] <- map.scale.output[[2]][names(map.scale.input[[2]])]

diffobj::diffStr(map.scale.input, map.scale.output)
```

The fill aesthetic is transformed into color codes.

### Geom$use_defaults

#### Description

For each layer, add the geom default aesthetics and aesthetics specified as
non-mapping parameters to the [layer function](#layer-function) to the data.  It
is worth noting that any aesthetics added by this mechanism are not [mapped by
the scales](#map-scale).

#### Signature

`$use_defaults([self], data, params)`

#### Parameters

* `self`: optional parameter, if present will point to the `Geom` `ggproto`
  object this method belongs to.
* `data`: the layer data for.
* `params`: the parameter list as matched to the aesthetics supported by the
  `Geom` (i.e. `Geom$aesthetics()`).

#### Value

Again, with our [example plot](#example-plot), we get:

```{r, echo=FALSE, results="asis"}
defaults.input <- map.scale.output
defaults.ouput <- list(structure(list(fill = c("#F8766D", "#00BA38", "#00BA38", "#619CFF"), xbin = c(1L, 30L, 1L, 30L), ybin = c(1L, 10L, 20L, 30L), value = c(1, 1, 1, 1), x = c(1.01666666666667, 1.98333333666667, 3.01666666666667, 3.98333333666667), y = c(5.05, 5.95000001, 6.95000001, 7.95000001), count = c(1, 1, 1, 1), density = c(1, 1, 1, 1), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = c(1L, 2L, 2L, 3L), xmin = c(0.999999996666667, 1.96666667, 2.99999999666667, 3.96666667), xmax = c(1.03333333666667, 2.00000000333333, 3.03333333666667, 4.00000000333333), ymin = c(4.99999999, 5.90000001, 6.90000001, 7.90000001), ymax = c(5.10000001, 6.00000001, 7.00000001, 8.00000001), colour = c(NA, NA, NA, NA), size = c(0.1, 0.1, 0.1, 0.1), linetype = c(1, 1, 1, 1), alpha = c(NA, NA, NA, NA), width = c(NA, NA, NA, NA), height = c(NA, NA, NA, NA)), row.names = c(NA, -4L), .Names = c("fill", "xbin", "ybin", "value", "x", "y", "count", "density", "PANEL", "group", "xmin", "xmax", "ymin", "ymax", "colour", "size", "linetype", "alpha", "width", "height"), class = "data.frame"), structure(list(fill = c("#F8766D", "#00BA38", "#00BA38", "#619CFF"), x = c(0.802855186536908, 2.15149602368474, 3.06846169922501, 4.36551264487207), y = c(4.76531683262438, 6.03128328304738, 6.72641851641238, 8.20721130892634), PANEL = structure(c(1L, 1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L, 2L, 2L, 3L), n = 3L), shape = c(21, 21, 21, 21), colour = c("black", "black", "black", "black"), size = c(1.5, 1.5, 1.5, 1.5), alpha = c(NA, NA, NA, NA), stroke = c(0.5, 0.5, 0.5, 0.5)), row.names = c(NA, -4L), .Names = c("fill", "x", "y", "PANEL", "group", "shape", "colour", "size", "alpha", "stroke"), class = "data.frame"))
diffobj::diffStr(defaults.input, defaults.output)
```

The second layer is the geom layer, and you can see how it gains defaults (e.g
`colour`, `alpha`, `stroke`) as well as the `shape` aesthetic that was specified
in the `geom_point` call of the [example plot](#example-plot).


### Geom$draw_panel

For `draw_panel` sigs, we have

* `GeomPoint`: `function(data, panel_params, coord, na.rm = FALSE)`
* `GeomRect`: `function(self, data, panel_params, coord)`
* `Geom`: `function(self, data, panel_params, coord, ...)`

From what I can infer from docs and source your function must accept at least
three arguments.  `draw_layer` from `Geom` will call `draw_panel` with three
unnamed parameters that in theory should match up to `data`, `panel_params`,
`coord`.

* `data`: A data.frame with all the aesthetic values as specified via `aes`.
  The column names corresponding to the aesthetic names, not the original data
  frame column names.  Additionally contains `PANEL`, `group` (set to -1 if
  there are no groups), and any default aesthetics specified in
  `Geom*$default_aes`.
* `panel_params`: named list, the intersection of parameters provided to the
  `geom_*` function with the formals of the `draw_panel` method, although you
  can customize `Geom` objects to return a specific eligible parameter list.
* `coord`: coord transformation functions?

Additionally, named parameters that are the intersection of the parameters
provided to the `geom_*` function by the user and the parameters of `draw_panel`
are supplied.

Finally, since `draw_panel` is a `ggproto` method `self` will be provided if it
is part of the `draw_panel` signature.

`setup_data` is used to convert parameters / aesthetics that are not in a format
amenable to plotting, to one that is.  One prime example is converting `width`
and `height` to `xmin/xmax` and `ymin/ymax` values.

In "Creating a new Geom", `draw_panel` is described as having 3 parameters,
instead of the 4 + (in particular starting with `self`) in other docs and in the
source.  Additionally, the `panel_scales` param appears to actually be
`panel_params`, at least in the sample fun we used (but `?Geom` also references
`panel_scales`).


### ggplot_gtable

can call to provide the `GeomX` object in the plot specification step.  Then
`ggplot_build` (step 2) and `ggplot_gtable` will use the methods in the provided
`ggproto` object to manipulate the data and produce grobs.


## Grid Stuff



## Glossary

These definitions are unofficial.  Some of them were made up by yours truly to
make it easier to reference recurrent concepts that lack formal definitions.

<dl>
<!---------------------------------------------------------------------------->
<dt><a name='aesthetic'></a>Aesthetic</dt>
<dd>
A variable that relates to a plot property, such as `x` position, or `size`, or
`color`.

Aesthetics come about in three ways in `ggplot2`:

* <a name='mapped-aesthetic'></a>Mapped aesthetics are specified with
  `aes(...)` via the `mapping` parameter to `ggplot()` or [layer
  functions](#layer-function) (e.g. `ggplot(data) + geom_point(aes(x=time,
  y=value)` where the mapped aesthetics are `x` and `y`.
* <a name='stat-aesthetic'></a>Stat aesthetics are generated by the [stat
  computation](#stat-compute) process.  They end up as additional variables in
  the computed layer data, and can be referenced with the `stat` call in the
  mapping specification (e.g. `stat_bin(aes(y=stat(ncount)))`).  Which stat
  aesthetics are generated depends on the statistic.  Sometimes this is
  documented in the [layer function](#layer-function) that applies the stat
  (e.g.  `?stat_bin`), but not always.  If the variables are not documented, you
  can look at the most specific [`Stat$compute_*`](#stat-compute) method that
  the [`Stat`](#ggproto-stat) defines.
* <a name='param-aesthetic'></a>Parameter aesthetics are specified in [layer
  functions](#layer-function) as part of `...`.  For example, in
  `geom_point(size=3)`, `size` is considered a parameter aesthetic because it is
  not part of the `mapping=aes(...)` call.  Unlike mapped aesthetics, parameter
  aesthetics are neither [transformed](scaletransform_df) nor
  [mapped](#map-scale).
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='position-aesthetic'></a>Aesthetic, Position</dt>
<dd>
[Aesthetic](#aesthetic) variables that correspond to position values.  `x` and
`y` are the most common ones, but there are many others such as `xmin`, `xmax`,
`xend`, and the corresponding `y` versions of those.

Position and non-position aesthetics are treated slightly differently in the
[`ggplot_build`](#ggplot_build) process.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='facet'></a>Facet</dt>
<dd>
<dt><a name='ggproto-facet'></a>Facet, `ggproto`</dt>
<dd>
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto-geom'></a>Geom, `ggproto`</dt>
<dd>
`Geom*` [`ggproto`](#ggproto) objects such as `GeomPoint` or `GeomRect` are
responsible for translating your data into graphical objects.  In `ggplot`
these graphical objects are called [grobs](#grid-graphical-object).  In order
to create your own geoms you will need to learn how to use `grid`, or
alternatively to re-use existing `Geom*` objects to generate grobs suited for
your purposes.

See `vignette(package='ggplot2', 'extending-ggplot2')` for examples of how to
extend `Geom` objects.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto'></a>Ggproto</dt>
<dd>
Object oriented framework used by `ggplot2`.  See `?ggplot2::ggproto` for
details.  `ggproto` objects contain functions (a.k.a.
[methods](#ggproto-method)) and data, both of which can be accessed with the `$`
or `[[` operators.  Common `ggproto` objects include:

* [`Coord`](#ggproto-coord).
* [`Geom`](#ggproto-geom).
* [`Layer`](#ggproto-layer).
* [`Layout`](#ggproto-layout).
* [`Position`](#ggproto-position).
* [`Scale`](#ggproto-scale).
* [`Stat`](#ggproto-stat).

`ggproto` objects are reference objects, so they can be modified in place.
Several `ggproto` [methods](#ggproto-method) will update the object they belong
to by reference.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto-method'></a>Ggproto Method</dt>
<dd>
A function that is part of a [`ggproto`](#ggproto) object.  It differs from
standard R functions because of the optional `self` parameter.  A `ggroto`
method that has the `self` parameter will be passed the [`ggproto`](#ggproto)
object the method belongs to as the value of that parameter when the it is
called.  This gives the method access to the object data and other methods, and
the opportunity to modify the `ggproto` object by reference.

We illustrate the use of `self` with a simple example.  Neither method call
provides the `self` parameter:

```{r eval=TRUE}
Example <- ggproto(
  "Example", NULL,
  method1=function(self, x) cat(sprintf("%s %s\n", x, self$secret)),
  method2=function(x) cat(sprintf("%s %s\n", x, self$secret)),
  secret="secret"
)
Example$method1("big")
Example$method2("big")
```

`ggproto` methods are generated at call time by the `$` method for `ggproto`
objects.  There are several implications to this.  One is that in order to see
the method body you need to resort to some contortions.  Here we do it for
`GeomPoint$setup_data`:

```{r}
GeomPoint$setup_data
environment(GeomPoint$setup_data)$f
```

Additionally `debug(Object$method)` will not work because next
time you call `Object$method` a new copy of the function is created.  To
`debug` `ggproto` methods you need to follow these steps:

```{r}
fun <- Object$method
debug(environment(fun)$f)
fun()
```

Depending on circumstances it may be easier to add a `browser` call to the
sources.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='grid'></a>Grid</dt>
<dd>
Low level graphics package that comes packaged by default with R.  It is used
by `ggplot` to draw the plots.  There are several useful vignettes you can
find with `browseVignettes('grid')`.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='grid-graphical-object'></a>Grid Graphical Objects</dt>
<dd>
A.k.a. grobs, R objects that contain a description of graphical elements that
can be used by the `grid` package to draw them on a graphical device.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto-layer'></a>Layer</dt>
<dd>
[`ggproto`](#ggproto) object responsible for computing and rendering plot
layers.  It contains `Geom`, `Stat`, and `Position` `ggproto` sub-objects, along
with other data and the methods that carry out the computation and translation
of layer data into [grobs](#grid-graphical-objects).

A `ggplot` may contain multiple layers.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto-layer'></a>Layer Data</dt>
<dd>
The data associated with a particular `Layer`.  This is a `data.frame`.  Layers
that do not have a `data.frame` explicitly associated by the [layer
function](#layer-function) will typically inherit the [plot data](#plot-data).
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto-layout'></a>Layout, `ggproto`</dt>
<dd>
[`ggproto`](#ggproto) object that contains all the metadata required to lay out
the plot across the panels.

One particular useful method is `Layout$get_scales`, which when given a panel id
will return a list with the position scales associated with that panel.

The [`Layout$layout` member](#layout-layout) is a table mapping panels to
scales and positions in the overall plot.
</dd>
<dt><a name='ggproto-position'></a>Position, `ggproto`</dt>
<dd>
`Position*` [`ggproto`](#ggproto) objects such as `PositionDodge` are
responsible for adjusting the position aesthetics in the layer data.  For
example, `PositionDodge` shifts and adjusts`x` [position
aesthetics](#position-aesthetic) such that objects overlapping on the `xmin`
aesthetic are placed side by side.

See [`Position$compute_*`](#position-compute) for details and `?Position`.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='layer-function'></a>Layer Function</dt>
<dd>
Functions that create [`Layer` `ggproto`](#ggproto-layer)) objects like
`geom_point` or `stat_bin`.  For example, in (a simplified version
of) `geom_point`:

```{r eval=FALSE}
geom_point <- function(
  mapping = NULL, data = NULL, stat = "identity", position = "identity"
)
  layer(
    data = data, mapping = mapping, stat = stat, geom = GeomPoint,
    position = position,
  )
```
The layer function calls `ggplot2::layer`. This function expands shortcut names
for [`ggproto` objects](#ggproto) into the corresponding `ggproto` objects.  In
`geom_point(position='jitter', size=2)` it translates the `'jitter'`
shortcut name into a `PositionJitter` [`ggproto` object](#ggproto), and
implicitly due to the default value for `stat` parameter it also translates the
string `'identity'` into the `StatIdentity` `ggproto` object.

These functions will allocate their parameters to
the various subcomponents of the [`Layer` `ggproto`](#ggproto-layer)) object
such as the [`Stat`](#ggproto-stat), [`Geom`](#ggproto-geom), or alternatively
to the aesthetic mapping specification.

Parameter matching is done by looking at the parameters for the corresponding
`ggproto` `$compute/draw_panel` methods, and if that method contains `...` in
the signature, also by looking at the parameters of the `ggproto`
`$compute/draw_group` methods.  For example, for `StatBin` we have:

```{r}
args(environment(ggplot2::StatBin$compute_panel)$f)
args(environment(ggplot2::StatBin$compute_group)$f)
```

Note: the `args(environment(...)$f)` business is required because [`ggproto`
methods](ggproto-methods) are not directly accessible.

Since `StatBin$compute_panel` has a `...` parameter, layer functions with
`StatBin` will match their parameters against the union of the
parameters for `$compute_panel` and `$compute_group`.  In the call
`stat_bin(bins=10)` the layer function `stat_bin` will match the parameter `bin`
to the `$compute_group` parameters, and as a result store that parameter in the
`StatBin$parameters` list.  This parameter list can then be used by other
`StatBin` methods such as [`StatBin$compute_group`](#stat-compute).
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='panel'></a>Panel</dt>
<dd>
Each plot layer is displayed across the plot [facets](#facet).  The portion of a
layer that matches up to a facet can be thought of as the panel.  Internally,
this corresponds to a subset of the rows of the layer data.  The `PANEL`
variable designates what facet each row in the layer data should be displayed
in.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='panel'></a>Plot Data</dt>
<dd>
The `data.frame` specified in the `ggplot(data=...)` call is the plot data.
[Layers](#layer) that are not explicitly assigned [layer data](#layer-data)
inherit this `data.frame` as their data.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto-scale'></a>Scale</dt>
<dd>
[`ggproto` object](#ggproto) that Contains meta data about the scales (e.g. the
range of values plotted under the scale) and [methods](#ggproto-method) to
transform the data.

For example, `scale_x_sqrt` produces a `ScaleContinuous` [`ggproto`](#ggproto)
object with a [`$transform` method](#scaletransform_df) that will covert any `x`
related aesthetics to their square roots.

There are is also typically a `$map` method to map the aesthetics into the
display space (e.g. categories into colors), although for [position
aesthetics](#position-aesthetic) that is typically handled by
`Coord$transform`.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto-scale-position'></a>Scale, Position</dt>
<dd>
[Scales](#ggproto-scale) that correspond to the [position
aesthetics](#position-aesthetic).
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='map-scale'></a>Scale, Map</dt>
<dd>
Use scales to convert aesthetic values into the domain they will be plotted in.
For example, values on a color/fill scale are converted to the colors they will
be displayed as.  Mapping for [position scales](#ggproto-scale-position) would
in theory convert values into the 0-1 range, but that is actually handled by the
coordinate transformation instead.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='train-scale'></a>Scale, Train</dt>
<dd>
Process that computes the range of values covered by a scale.  For continuous
scales this is typically just the min and max values, whereas for discrete
scales it is the sorted unique listing of all the different values.

Typically [position scales](#ggproto-scale-position) are trained several times
in the plot build process as they are used therein and the data is changed, e.g.
via statistics or position adjustments.
</dd>
<!---------------------------------------------------------------------------->
<dt><a name='ggproto-stat'></a>Stat</dt>
<dd>
`Stat*` [`ggproto`](#ggproto) objects such as `StatBin` are responsible for
[recomputing](#stat-compute) the layer data with a statistic and potentially
adding new variables.  For example, `StatBin` bins the data and computes `y`
values as well as other stats such as `count` and `ncount`.

See `vignette(package='ggplot2', 'extending-ggplot2')` for examples.
</dd>
</dl>
