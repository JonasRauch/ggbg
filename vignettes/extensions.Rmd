---
title: "Writing Ggplot2 Extensions"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{extensions}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(ggbg)
```

<b>This document is under development</b>.

## Introduction

When I set off to write my own `ggplot2` extensions I started by reading the
available documentation in `browseVignettes('ggplot2')` and `?Geom`.  That got
me started, but pretty quickly I found I needed more detail than was available
in those documents.  In particular I felt I did not have enough context about
the points at which `ggplot2` extensions hook in and how they interact with
different parts of `ggplot2`.

This document collects the subset of what I learned that might be useful to
developers that want to extend `ggplot2`.  This is unofficial documentation
based on the development version of `ggplot2` 2.3 circa 5/2018.

This document assumes the reader has some basic familiarity with:

* How to use `ggplot2` for plotting purposes.
* `ggproto`, the object system used by `ggplot2` (see `?ggplot2::ggproto`).
* `grid`, the graphical engine behind `ggplot2`.
* The [Extending Ggplot vignette][1].

## It's The Printing, Stupid

Four major steps are required to produce `ggplot`:

1. Specify (`ggplot() + ...`): user specifies what the plot
   should look like with `geom_*`, `stat_*`, `scale_*`, etc..
2. Build (`ggplot_build`): manipulate the data as directed by the user plot
   specification (e.g. apply stats, position adjustments, etc).
3. Create Grobs (`ggplot_gtable`): translate the data into `grid` graphical
   objects (grobs).
4. Render (`grid.draw`): display the graphical objects on a graphics device.

Step 1 is done directly by the user and will be familiar to all `ggplot2` users.
Steps 2-4 are triggered by the printing of a `ggplot2` object, as shown by this
simplified version of `print.ggplot`:

```{r eval=FALSE}
print.ggplot <- function (x, ...) {
  data <- ggplot_build(x)
  gtable <- ggplot_gtable(data)
  grid.draw(gtable)
}
```

Almost all the work `ggplot2` does is in these last three steps.  In order to
successfully extend `ggplot2` it helps to understand what happens in them,
particularly the `ggplot_build` and `ggplot_gtable` steps.  This documents
focuses mostly on the `ggplot_build` step.

## Extension Mechanism

`ggplot2` is extended by defining `ggproto` objects that inherit from the
existing `Geom`, `Stat`, `Position`, `Scale`, and/or `Facet` `ggproto` objects.

For example, if we want to define a new `Geom` "x", we create a `GeomX`
`ggproto` object that extends `Geom`, and we provide a layer function `geom_x`
that associates it with a `Layer` `ggproto` object.  Layer functions also
associate `Stat` and `Position` `ggproto` objects to the `Layer` object, along
with the aesthetic mapping and other parameters.

Layer functions typically end with a call to `ggplot2::layer`, which associates
the `ggproto` objects and data to the `Layer` object.  Here is a simplified
version of `geom_point` as an example:

```{r eval=FALSE}
geom_point <- function(
  mapping = NULL, data = NULL, stat = "identity", position = "identity"
)
  layer(
    data = data, mapping = mapping, stat = stat, geom = GeomPoint,
    position = position,
  )
```

Two non-obvious things `ggplot2::layer` does are: expand shortcut names for
`ggproto` objects into the corresponding `ggproto` object, and allocate
its other parameters to the different components.  In
`geom_point(position='jitter', size=2)`, `layer` translates the `'jitter'`
string into a `PositionJitter` `ggproto` object, and assigns the `size`
parameter to the aesthetic parameter list.  Implicitly due to the default value
for `stat` parameter it also translates the string `'identity'` into the
`StatIdentity` `ggproto` object.

`ggproto` objects contain logic (i.e. functions, a.k.a. methods) in addition to
data.  `ggplot_build` and `ggplot_gtable` will use these `ggproto` methods to
generate the plots.  In this way the layer extension mechanism allows us to
modify the plot generation mechanism.


## Data and Processing Patterns

The structure of `ggplot2` plots consists of:

* a plot
* that contains layers as specified by `geom_*` / `stat_*`
* that contain panels as specified by `facet_*`
* that contain groups as specified by the `group` aesthetic, or
  implicitly by the interaction of all the discrete aesthetics in the plot

Each layer has data associated to it.  It can be either layer specific data, or
data inherited from the plot itself (i.e. the data from `ggplot(data, ...)`).
The data is then divided across the panels and then across the groups by
adding the `PANEL` and `group` variables to the data.

Since data is not guaranteed to be associated with each layer until after the
`ggplot_build` process begins most of the `ggproto` objects have methods that
are called after the data are collected.  The two most common methods are:

* `setup_params()`
* `setup_data()`

These allow the `ggproto` objects to adjust parameters and data once the data
for each layer is collected.  This is useful for computing default values for
parameters that depend on the data, or to derive new aesthetics from existing
ones such as `xmin`/`xmax` values from `x` and `width` values.

Other methods present in most `Geom`, `Stat`, and `Position` that we are
interested in include:

* `compute_[layer|panel|group]()`
* `draw_[layer|panel|group]()`

Typically a `ggproto` object will have one set or the other.  For example `Geom`
objects have `draw_*` methods, whereas `Stat` objects have `compute_*` methods.
The method structure mirrors the data structure.  The `*_layer` methods are
called on the layer data, and they will typically call the `*_panel` methods
with the corresponding subset of the data, which then call the `*_group` methods
with the corresponding sub-subset of data.

The recommend approach to creating custom stats and geoms involves overriding
the `[compute|draw]_[panel|group]` methods for the `Geom*` and `Stat*` `ggproto`
objects..

## ggplot_build

`ggplot_build` starts with the input data and the plot specification.  It then
maps the data to aesthetics.  For example, it will map one of the data variables
or an expression of the data variables into an "x" coordinate.  It will then
apply transformations to the data/aesthetics based on the plot specification.
For the most part the `ggplot_build` process consists of many steps that each
take the data as an input along with various parameters, and output a modified
version of the data.  Modifications including adding/modifying
variables/aesthetics, or potentially completely recomputing the data.


sequentially applies the modifies the user data based on the plot
specification.  In it the user data passes through a series of functions that
sequentially modify it, by adding columns, recomputing values, etc.  Here we
provide an outline of all the key steps in the order in which they happen, and
with attribution to the `ggproto` object that is doing the work.  This is
intended to act as a reference so you can click through each step so you can see
what the inputs and outputs to each function are expected to be.

### Data Set-up

* Generate data for each layer, filling in with the plot data if necessary
* `Facet$setup_params()`: modifies facet parameters accounting for
  data (e.g. deriving default values for unspecified facet parameters).
  **Typically unused**.
* `Facet$setup_data()`:

  typically unused, allows modification of data.
* `Coord$setup_params()`
* `Coord$setup_data()`
* `Facet$compute_layout()`
* `Coord$setup_layout()`
* For each layer:
   * `Facet$map_data()` assigns data rows to facet panels.

### ggplot_gtable




the user
can call to provide the `GeomX` object in the plot specification step.  Then
`ggplot_build` (step 2) and `ggplot_gtable` will use the methods in the provided
`ggproto` object to manipulate the data and produce grobs.




## Hooks



1. Build (`ggplot_build`): analyzes and transforms data into a format suited for
   translation into graphical objects:
    1. Assigns facet panels.
    2. Computes aesthetic values from data and `aes(...)` specifications.
    3. Assigns groups.
    4. Rescales data if non linear scales are specified.
    5. Computes and maps statistics.
    6. Transforms special aesthetics (e.g. `width` to `xmin`-`xmax`)
       (Layer$compute_geom_1 -> Geom$setup_data, check_required_aesthetic)
    7. Adjusts positions (e.g. dodging/stacking with `$compute_positions`).
       (Layer$compute_positions ->
       Position$setup_params/setup_data/compute_layer)
    8. Recompute scales.
    9. Adds default aesthetics as needed.
2. Graphical Object Construction (`ggplot_gtable`):
    1. Applies coordinate transformations (if necessary)
    2. Translate the data into shapes, colors, positions, etc.
3. Rendering (`grid.draw`): display the resulting plot in a viewport.

Need to discuss what is implemented via the `ggproto` objects.

Each of the sub-steps in the build step is applied to every layer before moving
to the next step with the `by_layer` function.  Additionally, each proto driven
calculation follows this hierarchy:

`(draw|compute)_layer`
`(draw|compute)_panel`
`(draw|compute)_group`

The `*_layer` functions typically split the data by panel and forward each
chunk to the corresponding `*_panel` function.  The base `ggproto` `*_panel`
methods will split the data by group and forward it to the corresponding
`*_group` function.  This allows you to override either the `*_panel` or the
`*_group` function depending on what you are trying to do.

## Understanding the `data` Object

* Internal aesthetics
* Special variables (`group`, `panel`)
  * `group` are "integer" values from 1 to n where n is the number of groups, or
    -1 if there aren't any groups.
* Computed variables (`..level..`)

## Position Adjustments

Step 1.7 is carried out by modifying the coordinates in the data objects.
Both `position_dodge` and `position_stack` group data by `xmin` coordinate value
(either user provided, or derived from `x` and `width` or some such), and then
resolve any `xmin` overlaps by allocating the available width for each distinct
`group` (or should it be element?) within.

## Alternate Docs

### On `gg_proto`

Things to know:

* Objects that contain member functions and data
* The members can be accessed like list objects `object$member`
* When member functions are invoked they are always automatically provided with
  a `self` object if `self` is part of the signature (you can probably still
  access `self` even if it isn't in the sig, need to test).

### Ggplot Basics

### Mapping


### Rendering



Extending `ggplot` requires influencing how steps 1. and 2. are carried out.
This is done by creating layer functions (e.g. `geom_*` or `stat_*`) functions that return layers containing custom `Geom*` or `Stat*` objects.



```
 ## For reference, `sys.calls()` from a debugged `setup_data`:
 $ : language function (x, ...)  UseMethod("print")(x)
 $ : language print.ggplot(x)
 $ : language ggplot_build(x)
 $ : language by_layer(function(l, d) l$compute_geom_1(d))
 $ : language f(l = layers[[i]], d = data[[i]])
 $ : language l$compute_geom_1(d)
 $ : language f(..., self = self)
 $ : language self$geom$setup_data(data, c(self$geom_params, self$aes_params))
 $ : language f(...)
```

### Geom Basics

To implement a geom you need:

* A `geom_*` standard function
* A `Geom*` object, possibly re-used from an existing geom

### The `Geom*` Object

`Geom*` objects such as `GeomPoint` or `GeomRect` are responsible for
translating your data into graphical objects.  In `ggplot` these graphical
objects are called "grobs", short for Grid Graphical Objects, because they are
encoded in a format defined by the `grid` R package.  In order to create your
own geoms you will need to learn how to use `grid`, or alternatively to re-use
existing `Geom*` objects to generate grobs suited for your purposes.  For
example in this package we re-use `GeomRect` for `GeomWaterfall`.

`Geom*` objects are implemented using `ggproto`, a `ggplot2` specific Object
Oriented framework.  `ggproto` is derived from the `proto` R OOP package.



## Extending Ggplot 2 vignette

### What `ggplot2` Does

### Creating Geoms

The `setup_data` and `draw_panel` functions we referenced above are part of the
`Geom*` `ggproto` objects.

`setup_data` is used to convert parameters / aesthetics that are not in a format
amenable to plotting, to one that is.  One prime example is converting `width`
and `height` to `xmin/xmax` and `ymin/ymax` values.


In "Creating a new Geom", `draw_panel` is described as having 3 parameters,
instead of the 4 + (in particular starting with `self`) in other docs and in the
source.  Additionally, the `panel_scales` param appears to actually be
`panel_params`, at least in the sample fun we used (but `?Geom` also references
`panel_scales`).

For `draw_panel` sigs, we have

* `GeomPoint`: `function(data, panel_params, coord, na.rm = FALSE)`
* `GeomRect`: `function(self, data, panel_params, coord)`
* `Geom`: `function(self, data, panel_params, coord, ...)`

From what I can infer from docs and source your function must accept at least
three arguments.  `draw_layer` from `Geom` will call `draw_panel` with three
unnamed parameters that in theory should match up to `data`, `panel_params`,
`coord`.

* `data`: A data.frame with all the aesthetic values as specified via `aes`.
  The column names corresponding to the aesthetic names, not the original data
  frame column names.  Additionally contains `PANEL`, `group` (set to -1 if
  there are no groups), and any default aesthetics specified in
  `Geom*$default_aes`.
* `panel_params`: named list, the intersection of parameters provided to the
  `geom_*` function with the formals of the `draw_panel` method, although you
  can customize `Geom` objects to return a specific eligible parameter list.
* `coord`: coord transformation functions?

Additionally, named parameters that are the intersection of the parameters
provided to the `geom_*` function by the user and the parameters of `draw_panel`
are supplied.

Finally, since `draw_panel` is a `ggproto` method `self` will be provided if it
is part of the `draw_panel` signature.

## Deprecated Stuff

### `setup_data` vs `reparametrise`

It seems like both those functions can be used for the same purpose.  For
example, in `GeomRect`, `setup_data` is explicitly used to convert width to
`xmax/xmin`.

Actually, looks like `reparameterise` doesn't exist anymore?

draw_legend / draw_key

## Grid Stuff

You cannot use `gList` in the key/legend.  However, `grobTree` works.

[1]: https://cran.r-project.org/package=ggplot2/vignettes/extending-ggplot2.html
