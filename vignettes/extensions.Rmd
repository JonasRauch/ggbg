---
title: "Writing Ggplot2 Extensions"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{extensions}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(ggbg)
```

<b>This document is under development</b>.

## Introduction

This document is an unofficial reference for developers looking to extend
`ggplot2`.  It is a supplement to existing documentation that provides more
detail about how the extension mechanism interacts with other parts of the
`ggplot2` plot building process.  It is based on examination of the sources of
`ggplot2` circa 5/2018 (version 2.3 pre-release).

We assume the reader is familiar with using `ggplot2` for generating plots, and
that the reader has previously reviewed:

* `?ggproto` for an introduction to the `ggplot2` object oriented programming
  system.
* `?ggplot2::ggplot2-ggproto` for the major `ggproto` objects used by `ggplot2`.
* `vignette(package='ggplot2', 'extending-ggplot2')` for the official
  documentation on extending `ggplot2`.

There are four major sections to this document:

1. Overview: A high level look at the process of converting data and user
   `ggplot2` plot specifications into a plot.
2. Process Outline: The listing of all the key function calls used by `ggplot2`
   to generate the plot.  This gives you a sense for where your extension fits
   in relation to the rest of the process.  Most steps in the outline are
   hyperlinked to the "Process Detail" section.
3. Process Detail: More detail on the important steps in the plot generation
   process, including descriptions of inputs, outputs, and other relevant
   information for anyone looking to modify those steps.
4. Definitions: Definitions of key terms.  These are hyperlinked throughout the
   document.

## Overview

### It's The Printing, Stupid

Four major steps are required to produce `ggplot`:

1. Specify (`ggplot() + ...`): user specifies what the plot
   should look like with `geom_*`, `stat_*`, `scale_*`, etc..
2. Build (`ggplot_build`): manipulate the data as directed by the user plot
   specification (e.g. apply stats, position adjustments, etc).
3. Create Grobs (`ggplot_gtable`): translate the data into `grid` graphical
   objects (grobs).
4. Render (`grid.draw`): display the graphical objects on a graphics device.

Step 1 is done directly by the user and will be familiar to all `ggplot2` users.
Steps 2-4 are triggered by the printing of a `ggplot2` object, as shown by this
simplified version of `print.ggplot`:

```{r eval=FALSE}
print.ggplot <- function (x, ...) {
  data <- ggplot_build(x)
  gtable <- ggplot_gtable(data)
  grid.draw(gtable)
}
```

Almost all the work `ggplot2` does is in these last three steps.  In order to
successfully extend `ggplot2` it helps to understand what happens in them,
particularly the `ggplot_build` and `ggplot_gtable` steps.  This documents
focuses mostly on the `ggplot_build` step.

### Extension Mechanism

`ggplot2` is extended by defining [`ggproto` objects](#ggproto) that inherit
from the existing [`Geom`](#ggproto-geom), [`Stat`](#ggproto-geom),
[`Position`](#ggproto-geom), `Scale`, `Coord` and/or `Facet` `ggproto` objects.
`ggproto` objects contain both data and functions (a.k.a. methods), so this
allows users to override `ggplot2` default behavior by providing new [`ggproto`
methods](#ggproto-method).

For example, if we want to define a new `Geom` "x", we create a `GeomX`
`ggproto` object that extends `Geom`, and we provide a [layer
function](#layer-function) that associates it and other `ggproto` objects and parameters with a [`Layer` `ggproto` object](#ggproto-layer).

**DON'T LOVE TRANSITION FROM geom_x TO geom_point HERE**


Once the layer function is done with the associations it returns the `Layer`
`ggproto` object.

`ggproto` objects contain logic (i.e. functions, a.k.a. methods) in addition to
data.  `ggplot_build` and `ggplot_gtable` will use these `ggproto` methods to
generate the plots.  In this way the layer extension mechanism allows us to
modify the plot generation mechanism.

### Data and Processing Patterns

The structure of `ggplot2` plots consists of:

* a plot
* that contains layers as specified by `geom_*` / `stat_*`
* that contain panels as specified by `facet_*`
* that contain groups as specified by the `group` aesthetic, or
  implicitly by the interaction of all the discrete aesthetics in the plot

Each layer has data associated to it.  It can be either layer specific data, or
data inherited from the plot itself (i.e. the data from `ggplot(data, ...)`).
The data is then divided across the panels and then across the groups by
adding the `PANEL` and `group` variables to the data.

Other methods present in most `Geom`, `Stat`, and `Position` that we are
interested in include:

* `compute_[layer|panel|group]()`
* `draw_[layer|panel|group]()`

Typically a `ggproto` object will have one set or the other.  For example `Geom`
objects have `draw_*` methods, whereas `Stat` objects have `compute_*` methods.
The method structure mirrors the data structure.  The `*_layer` methods are
called on the layer data, and they will typically call the `*_panel` methods
with the corresponding subset of the data, which then call the `*_group` methods
with the corresponding sub-subset of data.

The recommend approach to creating custom stats and geoms involves overriding
the `[compute|draw]_[panel|group]` methods for the `Geom*` and `Stat*` `ggproto`
objects.

## Method Outline

### ggplot_build

`ggplot_build` starts with the input data and the plot specification.  It then
proceeds through several steps that sequentially transform the data by adding
and/or recomputing variables, or in the case of statistics recomputing the
entire data.  In addition to transforming the data, the build process also
updates and computes meta data for scales, facets, etc.  The work is carried out
by the methods of `ggproto` objects provided implicitly via the plot
specification.

A simplified outline of the methods called by `ggplot_build` follows.  This is
not comprehensive and hides some of the logic.  For example, some methods are
called for every layer, or every panel, and that is not shown here.  This
outline is intended to give a rough idea of what happens in what order.  It also
acts as an index to more comprehensive documentation for the key methods.

* [`Layer$layer_data`](#layer-layer_data): assign data to layer
* `Layout$setup`:
    * [`Facet$setup_params`](#setup_params-setup_data): unused by common `Facet`
      objects.
    * [`Facet$setup_data`](#setup_params-setup_data): unused by common `Facet`
      objects.
    * [`Coord$setup_data`](#setup_params-setup_data): unused by common `Coord`
      objects.
    * [`Facet$compute_layout`](#facet-compute_layout): generate facet meta data.
    * `Coord$setup_layout`:
    * [`Facet$map_data`](#facet-map-data): add the `PANEL` variable that maps
      data rows to facets.
* [`Layer$compute_aesthetics`](#layer-compute-aesthetics): compute aesthetics,
  add `group` variable.
* [`Scale$transform_df`](#scale-transform-df): apply scale transformations to
  aesthetics.
* `Layout$train_position`: initialize scales.
* [`Layout$map_position`](#layout-map-position): For each layer, map position
  (x/y) scales.
* `Layer$compute_statistic`: recompute data with statistics.
    * [`Stat$setup_params`](#setup_params-setup_data): adjust params.
    * [`Stat$setup_data`](#setup_params-setup_data): adjust data.
    * [`Stat$compute_layer`](#stat-compute): apply statistic to each layer.
    * [`Stat$compute_panel`](#stat-compute): apply statistic to each panel.
    * [`Stat$compute_group`](#stat-compute): apply statistic to each group.

### ggplot_gtable




## Method Details

### Example Plot

We illustrate inputs and outputs to some of the methods documented in this
section with the following plot:

```{r, eval=FALSE}
dat <- data.frame(
  loc=(1:4)^2,
  val=(5:8)^2,
  grp=c('A', 'B', 'B', 'C'),
  pnl=c('P1', 'P1', 'P2', 'P2')
)
library(ggplot2)
p <- ggplot(dat, aes(x=loc, y=val, fill=grp)) +
  stat_bin2d() +
  geom_point(position="jitter", shape=21) +
  facet_wrap(~pnl, scales="free_x") +
  scale_x_sqrt() +
  scale_y_sqrt()
```

It involves a standard layer, a statistic layer, it has facets, and it scales
the [postion aesthetics](#position-aesthetic).

### Layer$layer_data

For each layer, this process assigns the data to be used, which is either the
data specified in the `geom_*` / `stat_*` call if any, or if not the data
specified in the `ggplot()` call.  Because neither layer in the plot had data
they both acquire the plot data.

### Object$setup_params And Object$setup_data {setup_param-setup_data}

#### Description

`ggplot2` has a complex specification system.  In most cases, the user
input specification is relatively simple, but `ggplot2` then needs to set or
compute default values for derived variables and parameters.  To assist with
this most of the [`ggproto` objects](#ggproto) have `setup_params` and
`setup_data` methods.  These are often called after some of the initial setup
has been done (e.g. assigning layer data) so that they can use this information
to update the data or parameters.

For example, `Facet$setup_params` is called with a list containing the plot data
and every layer data after the data is associated to each layer.  This gives the
method the opportunity to update the parameters in the context of the entirety
of the data.

The `setup_data` methods provide an opportunity to update the data, also after
the data has been assigned to layers, and after the parameters have been updated
with the `setup_params` methods. An example is how some `Geoms` will add `xmin`
and `xmax` aesthetics computed from existing `x` and `width` aesthetics with the
`setup_data` method.

#### Signature

`$setup_params([self], data, params)`
`$setup_data([self], data, params)`

The `self` parameter, if present, can appear anywhere in the signature.  The
other two parameters must be in the relative order shown above.

#### Parameters

* `self`: optional parameter, if present will point to the `ggproto` object the
  method belongs to.
* `data`: the layer data.  Depending on which `ggproto` object the `setup_*`
  method belongs to it may have undergone scale transformation and/or mapping.
  See the [method outline](#method-outline) to get an idea of the state of the
  data by the time it gets to the `setup_*` method in question.
* `params`: a list of the parameters provided to the [layer
  function](#layer-function) that match the parameters of the
  `$[compute|draw]_panel` of `self`, and if that method has a `...` parameter,
  then also the parameters of the `$[compute|draw]_group` method.

### Facet$compute_layout

Assigns a panel, row, column, and position scale ids to each facet.  It is
possible to have multiple position scales in a plot when the scales are "free".

This is what this data looks like for our [example plot](#example-plot):

```
  PANEL ROW COL pnl SCALE_X SCALE_Y
1     1   1   1  P1       1       1
2     2   1   2  P2       2       1
```

Our data has two facets (panels) arranged across two columns and in one row.
There is one `y` scale, and two `x` scales because with set "free_x" in the
facet specification for the plot.

This data then becomes the `layout` member of the [`Layout`
`ggproto`](#ggproto-layout) object.

### Facet$map_data

Add the `PANEL` variable to the data.  Here we show the effect it has on the
data of the first layer:

```{r, echo=FALSE}
input <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor")), .Names = c("loc", "val", "grp",
"pnl"), row.names = c(NA, -4L), class = "data.frame")
output <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor"), PANEL = structure(c(1L, 1L, 2L,
    2L), .Label = c("1", "2"), class = "factor")), .Names = c("loc",
"val", "grp", "pnl", "PANEL"), row.names = c(NA, 4L), class = "data.frame")
diffobj::diffPrint(input, output)
```

### Layer$compute_aesthetic

For each layer,  evaluates all the non-computed `aes(...)` expressions and
replace the data variables with the resulting aesthetics.  Computed aesthetics
(i.e. those containing calls to `stat`) are calculated later  **WHEN?**.  This
step also infers the `group` aesthetic from the interaction of categorical
variables specified in `aes(...)`.

Here we show the effect on one of the layer's data:

```{r, echo=FALSE}
input <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor"), PANEL = structure(c(1L, 1L, 2L,
    2L), .Label = c("1", "2"), class = "factor")), .Names = c("loc",
"val", "grp", "pnl", "PANEL"), row.names = c(NA, 4L), class = "data.frame")
output <- structure(list(x = c(1, 4, 9, 16), y = c(25, 36, 49, 64), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), row.names = c(NA, -4L), class = "data.frame")
diffobj::diffPrint(input, output)
```

The variable have changed to be the aesthetics, and we gain the `group`
variable.

### Scale$transform_df

This is applies scale transformations to each layer.  In our example, we use
`scale_*_sqrt`.  Here is the effect on the data for one of the layers:

```{r, echo=FALSE}
input <- structure(list(x = c(1, 4, 9, 16), y = c(25, 36, 49, 64), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), row.names = c(NA, -4L), class = "data.frame")
output <- structure(list(x = c(1, 2, 3, 4), y = c(5, 6, 7, 8), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), class = "data.frame", row.names = c(NA, -4L))
diffobj::diffPrint(input, output)
```

The transformation is applied to all the aesthetics that are associated with the
scale.  For example, continuous `x` scales will transform the `x` aesthetic, but
also `xmin`, `xmax`, `xend`, `xintercept`, and several others.

### Layout$map_position

For each layer, map data with position (x/y) scales.  This in theory would
rescale the position aesthetics (e.g. `x`, `xmin`, `xmax`, `y`, etc.), but
because "the coordinate system takes care of it" the only thing this does is
handle NAs and convert integer aesthetics to numeric.

### Stat$compute_layer/panel/group {#stat-compute}

#### Description

These methods are responsible for applying a statistic to the layer data and
returning the result as the new layer data.  Typically you would modify one of
the group, panel, or layer methods, starting with the group method if possible,
and working up the chain depending on how much control you require over the
whole process.  The default layer and panel method respectively run the panel
and group methods over each panel and group.  The further up the chain you
override these methods, the more work you will need to do.

#### Signature

`$compute_layer([self], data, params, layout)`
`$compute_panel([self], data, scales, ...)`
`$compute_group([self], data, scales)`

#### Parameters

* `self`: optional parameter, if present will point to the `Stat` `ggproto`
  object the method belongs to.
* `data`: the layer data for `$compute_layer`, a subset of the layer data
  corresponding to a panel for `$compute_panel`, or a subset of the panel data
  corresponding to a group for `$compute_group`.
* `params`: the parameter list as matched to the `$compute_panel/group` methods
  by the layer function.
* `layout`: the [`Layout` `ggproto`](#ggproto-layout) object for the plot.
* `scales`: the [`Scales` `ggproto`](#ggproto-scales) object for the plot.

#### Value

Here is what the data looks like before and after it is computed on by these
methods for our [example plot](#example-plot):

```
```


### Geom$draw_panel

For `draw_panel` sigs, we have

* `GeomPoint`: `function(data, panel_params, coord, na.rm = FALSE)`
* `GeomRect`: `function(self, data, panel_params, coord)`
* `Geom`: `function(self, data, panel_params, coord, ...)`

From what I can infer from docs and source your function must accept at least
three arguments.  `draw_layer` from `Geom` will call `draw_panel` with three
unnamed parameters that in theory should match up to `data`, `panel_params`,
`coord`.

* `data`: A data.frame with all the aesthetic values as specified via `aes`.
  The column names corresponding to the aesthetic names, not the original data
  frame column names.  Additionally contains `PANEL`, `group` (set to -1 if
  there are no groups), and any default aesthetics specified in
  `Geom*$default_aes`.
* `panel_params`: named list, the intersection of parameters provided to the
  `geom_*` function with the formals of the `draw_panel` method, although you
  can customize `Geom` objects to return a specific eligible parameter list.
* `coord`: coord transformation functions?

Additionally, named parameters that are the intersection of the parameters
provided to the `geom_*` function by the user and the parameters of `draw_panel`
are supplied.

Finally, since `draw_panel` is a `ggproto` method `self` will be provided if it
is part of the `draw_panel` signature.


### ggplot_gtable




the user
can call to provide the `GeomX` object in the plot specification step.  Then
`ggplot_build` (step 2) and `ggplot_gtable` will use the methods in the provided
`ggproto` object to manipulate the data and produce grobs.




## Hooks



1. Build (`ggplot_build`): analyzes and transforms data into a format suited for
   translation into graphical objects:
    1. Assigns facet panels.
    2. Computes aesthetic values from data and `aes(...)` specifications.
    3. Assigns groups.
    4. Rescales data if non linear scales are specified.
    5. Computes and maps statistics.
    6. Transforms special aesthetics (e.g. `width` to `xmin`-`xmax`)
       (Layer$compute_geom_1 -> Geom$setup_data, check_required_aesthetic)
    7. Adjusts positions (e.g. dodging/stacking with `$compute_positions`).
       (Layer$compute_positions ->
       Position$setup_params/setup_data/compute_layer)
    8. Recompute scales.
    9. Adds default aesthetics as needed.
2. Graphical Object Construction (`ggplot_gtable`):
    1. Applies coordinate transformations (if necessary)
    2. Translate the data into shapes, colors, positions, etc.
3. Rendering (`grid.draw`): display the resulting plot in a viewport.

Need to discuss what is implemented via the `ggproto` objects.

Each of the sub-steps in the build step is applied to every layer before moving
to the next step with the `by_layer` function.  Additionally, each proto driven
calculation follows this hierarchy:

`(draw|compute)_layer`
`(draw|compute)_panel`
`(draw|compute)_group`

The `*_layer` functions typically split the data by panel and forward each
chunk to the corresponding `*_panel` function.  The base `ggproto` `*_panel`
methods will split the data by group and forward it to the corresponding
`*_group` function.  This allows you to override either the `*_panel` or the
`*_group` function depending on what you are trying to do.

## Understanding the `data` Object

* Internal aesthetics
* Special variables (`group`, `panel`)
  * `group` are "integer" values from 1 to n where n is the number of groups, or
    -1 if there aren't any groups.
* Computed variables (`..level..`)

## Position Adjustments

Step 1.7 is carried out by modifying the coordinates in the data objects.
Both `position_dodge` and `position_stack` group data by `xmin` coordinate value
(either user provided, or derived from `x` and `width` or some such), and then
resolve any `xmin` overlaps by allocating the available width for each distinct
`group` (or should it be element?) within.

## Alternate Docs

### On `gg_proto`

Things to know:

* Objects that contain member functions and data
* The members can be accessed like list objects `object$member`
* When member functions are invoked they are always automatically provided with
  a `self` object if `self` is part of the signature (you can probably still
  access `self` even if it isn't in the sig, need to test).
* You cannot debug `ggproto` methods directly because they are wrapped on the
  fly by `$.ggproto`.  To debug, first extract the method, then `debug` it, then
  `debug` `f` inside of it...

### Ggplot Basics

### Mapping


### Rendering



Extending `ggplot` requires influencing how steps 1. and 2. are carried out.
This is done by creating layer functions (e.g. `geom_*` or `stat_*`) functions that return layers containing custom `Geom*` or `Stat*` objects.



```
 ## For reference, `sys.calls()` from a debugged `setup_data`:
 $ : language function (x, ...)  UseMethod("print")(x)
 $ : language print.ggplot(x)
 $ : language ggplot_build(x)
 $ : language by_layer(function(l, d) l$compute_geom_1(d))
 $ : language f(l = layers[[i]], d = data[[i]])
 $ : language l$compute_geom_1(d)
 $ : language f(..., self = self)
 $ : language self$geom$setup_data(data, c(self$geom_params, self$aes_params))
 $ : language f(...)
```

### Geom Basics

To implement a geom you need:

* A `geom_*` standard function
* A `Geom*` object, possibly re-used from an existing geom

### The `Geom*` Object




## Extending Ggplot 2 vignette

### What `ggplot2` Does

### Creating Geoms

`setup_data` is used to convert parameters / aesthetics that are not in a format
amenable to plotting, to one that is.  One prime example is converting `width`
and `height` to `xmin/xmax` and `ymin/ymax` values.

In "Creating a new Geom", `draw_panel` is described as having 3 parameters,
instead of the 4 + (in particular starting with `self`) in other docs and in the
source.  Additionally, the `panel_scales` param appears to actually be
`panel_params`, at least in the sample fun we used (but `?Geom` also references
`panel_scales`).


## Deprecated Stuff

### `setup_data` vs `reparametrise`

It seems like both those functions can be used for the same purpose.  For
example, in `GeomRect`, `setup_data` is explicitly used to convert width to
`xmax/xmin`.

Actually, looks like `reparameterise` doesn't exist anymore?

draw_legend / draw_key

## Grid Stuff

You cannot use `gList` in the key/legend.  However, `grobTree` works.

[1]: https://cran.r-project.org/package=ggplot2/vignettes/extending-ggplot2.html

## Glossary

<dl>
<dt><a name='aesthetic'></a>Aesthetic</dt>
  A variable that maps to a plot property, such as `x` position, or
  `size`, or `color`.  `ggplot2` allows users to specify the mapping with the
  `mapping` argument to either the `ggplot` function or the [layer
  functions](#layer-function).

  After the initial specification by the user, aesthetic values are scaled, and
  eventually mapped to their actual display values.
<dd>
</dd>
<dt><a name='position-aesthetic'></a>Aesthetic, Position</dt>
<dd>
  [Aesthetic](#aesthetic) variables that correspond to position values.  `x` and
  `y` are the most common ones, but there are many others such as `xmin`, `xmax`,
  `xend`.

</dd>
<dt><a name='ggproto'></a>Ggproto</dt>
<dd>
  Object oriented framework used by `ggplot2`.  See `?ggplot2::ggproto` for
  details.
</dd>
<dt><a name='ggproto-geom'></a>Ggproto Geom</dt>
<dd>
  `Geom*` [`ggproto`](#ggproto) objects such as `GeomPoint` or `GeomRect` are
  responsible for translating your data into graphical objects.  In `ggplot`
  these graphical objects are called [grobs](#grid-graphical-object).  In order
  to create your own geoms you will need to learn how to use `grid`, or
  alternatively to re-use existing `Geom*` objects to generate grobs suited for
  your purposes.

  You can extend `Geom` objects by overriding the
  [`Geom$setup_data`](#geom-setup-data),
  [`Geom$setup_param`](#geom-setup-param),
  [`Geom$draw_panel`](#geom-draw-panel), and/or
  [`Geom$draw_group`](#geom-draw-group) methods.  See
  `vignette(package='ggplot2', 'extending-ggplot2')` for examples.
</dd>
<dt><a name='ggproto-layer'></a>Ggproto Layer</dt>
<dd>
  `ggproto` object responsible for computing and rendering plot layers.  It
  contains `Geom`, `Stat`, and `Position` `ggproto` sub-objects, along with
  other data and the methods that carry out the computation and translation of
  layer data into [grobs](#grid-graphical-objects).
</dd>
<dt><a name='ggproto-layout'></a>Ggproto Layout</dt>
<dd>
  Contains all the metadata required to lay out the plot across the panels.
  **stub**
</dd>
<dt><a name='ggproto-method'></a>Ggproto Method</dt>
<dd>
  A function that is part of a [`ggproto`](#ggproto) object.  It differs from
  standard R functions because of the optional `self` parameter.  A `ggroto`
  method that has the `self` parameter will be passed the [`ggproto`](#ggproto)
  object the method belongs to as the value of that parameter when the it is
  called.  This gives the method access to the object data and other methods.

  We illustrate the use of `self` with a simple example.  Neither method call
  provides the `self` parameter:

  ```{r eval=TRUE}
  Example <- ggproto(
    "Example", NULL,
    method1=function(self, x) cat(sprintf("%s %s\n", x, self$secret)),
    method2=function(x) cat(sprintf("%s %s\n", x, self$secret)),
    secret="secret"
  )
  Example$method1("big")
  Example$method2("big")
  ```

  `ggproto` methods are generated at call time by the `$` method for `ggproto`
  objects.  This means that `debug(Object$method)` will not work because next
  time you call `Object$method` a new copy of the function is created.  To
  `debug` `ggproto` methods you need to first generate the function `fun <-
  Object$method`, then `debug(fun); fun()`, and then inside the debugged `fun`,
  `debug(f)` as the method is itself a wrapper around the actual
  function, which is stored in `f`.  Depending on circumstances it may be easier
  to add a `browser` call to the sources.
</dd>
<dt><a name='ggproto-position'></a>Ggproto Position</dt>
<dd>
  `Position*` [`ggproto`](#ggproto) objects such as `PositionDodge` are
  responsible for adjusting the position aesthetics in the layer data.
  For example, `PositionDodge` shifts `x` [position
  aesthetics](#position-aesthetic) bins the data and computes `y` values a
  well as other [computed aesthetics](#computed-aesthetics) stats such as
  `count` and `ncount`.

  You can extend `Position` objects by overriding
  the [`Position$setup_data`](#position-setup-data),
  [`Position$setup_param`](#position-setup-param),
  [`Position$compute_panel`](#position-compute-panel),
  and/or [`Position$compute_group`](#position-compute-group) methods.  See
  the sources for `Position` objects for examples.
</dd>
<dt><a name='ggproto-stat'></a>Ggproto Stat</dt>
<dd>
  `Stat*` [`ggproto`](#ggproto) objects such as `StatBin` are responsible for
  recomputing the plot data with a statistic and potentially adding new
  variables.  For example, `StatBin` bins the data and computes `y` values as
  well as other stats such as `count` and `ncount`.

  You can extend `Stat` objects by overriding
  the [`Stat$setup_data`](#stat-setup-data),
  [`Stat$setup_param`](#stat-setup-param),
  [`Stat$compute_panel`](#stat-compute-panel),
  and/or [`Stat$compute_group`](#stat-compute-group) methods.  See
  `vignette(package='ggplot2', 'extending-ggplot2')` for examples.
</dd>
<dt><a name='grid'>Grid</dt>
<dd>
  Low level graphics package that comes packaged by default with R.  It is used
  by `ggplot` to draw the plots.  There are several useful vignettes you can
  find with `browseVignettes('grid')`.
</dd>
<dt><a name='grid-graphical-object'>Grid Graphical Objects</dt>
<dd>
  A.k.a. grobs, R objects that contain description of graphical elements that
  can be used by the `grid` package to draw them on a graphical device.
</dd>
<dt><a name='layer-function'></a>Layer Function</dt>
<dd>
  Functions that create [`Layer` `ggproto`](#ggproto-layer)) objects like
  `geom_point` or `stat_bin`.  For example, in (a simplified version
  of) `geom_point`:  

  ```{r eval=FALSE}
  geom_point <- function(
    mapping = NULL, data = NULL, stat = "identity", position = "identity"
  )
    layer(
      data = data, mapping = mapping, stat = stat, geom = GeomPoint,
      position = position,
    )
  ```

  The layer function calls `ggplot2::layer`. This function expands shortcut names
  for `ggproto` objects into the corresponding `ggproto` objects.  In
  `geom_point(position='jitter', size=2)` it translates the `'jitter'` string into
  a `PositionJitter` `ggproto` object, and implicitly due to the default value for
  `stat` parameter it also translates the string `'identity'` into the
  `StatIdentity` `ggproto` object.



  These functions will allocate their parameters to
  the various subcomponents of the [`Layer` `ggproto`](#ggproto-layer)) object
  such as the [`Stat`](#ggproto-stat), [`Geom`](#ggproto-geom), or `ggproto`
  objects, and return the [`Layer` object](#ggprot-layer).


  Other parameters to the [layer function](#layer-function) are matched to its
  subcomponents.  In this example, the `size` parameter is associated with the
  `Geom` subcomponent.

</dd>
</dl>
