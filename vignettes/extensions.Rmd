---
title: "Writing Ggplot2 Extensions"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{extensions}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(ggbg)
```

<b>This document is under development</b>.

## Introduction

When I set off to write my own `ggplot2` extensions I started by reading the
available documentation in `browseVignettes('ggplot2')` and `?Geom`.  That got
me started, but pretty quickly I found I needed more detail than was available
in those documents.  In particular I felt I did not have enough context about
the points at which `ggplot2` extensions hook in and how they interact with
different parts of `ggplot2`.

This document collects the subset of what I learned that might be useful to
developers that want to extend `ggplot2`.  This is unofficial documentation
based on the development version of `ggplot2` 2.3 circa 5/2018.

This document assumes the reader has some basic familiarity with:

* How to use `ggplot2` for plotting purposes.
* `ggproto`, the object system used by `ggplot2` (see `?ggplot2::ggproto`).
* `grid`, the graphical engine behind `ggplot2`.
* The [Extending Ggplot vignette][1].

## It's The Printing, Stupid

Four major steps are required to produce `ggplot`:

1. Specify (`ggplot() + ...`): user specifies what the plot
   should look like with `geom_*`, `stat_*`, `scale_*`, etc..
2. Build (`ggplot_build`): manipulate the data as directed by the user plot
   specification (e.g. apply stats, position adjustments, etc).
3. Create Grobs (`ggplot_gtable`): translate the data into `grid` graphical
   objects (grobs).
4. Render (`grid.draw`): display the graphical objects on a graphics device.

Step 1 is done directly by the user and will be familiar to all `ggplot2` users.
Steps 2-4 are triggered by the printing of a `ggplot2` object, as shown by this
simplified version of `print.ggplot`:

```{r eval=FALSE}
print.ggplot <- function (x, ...) {
  data <- ggplot_build(x)
  gtable <- ggplot_gtable(data)
  grid.draw(gtable)
}
```

Almost all the work `ggplot2` does is in these last three steps.  In order to
successfully extend `ggplot2` it helps to understand what happens in them,
particularly the `ggplot_build` and `ggplot_gtable` steps.  This documents
focuses mostly on the `ggplot_build` step.

## Extension Mechanism

`ggplot2` is extended by defining `ggproto` objects that inherit from the
existing `Geom`, `Stat`, `Position`, `Scale`, and/or `Facet` `ggproto` objects.

For example, if we want to define a new `Geom` "x", we create a `GeomX`
`ggproto` object that extends `Geom`, and we provide a layer function `geom_x`
that associates it with a `Layer` `ggproto` object.  Layer functions also
associate `Stat` and `Position` `ggproto` objects to the `Layer` object, along
with the aesthetic mapping and other parameters.

Layer functions typically end with a call to `ggplot2::layer`, which associates
the `ggproto` objects and data to the `Layer` object.  Here is a simplified
version of `geom_point` as an example:

```{r eval=FALSE}
geom_point <- function(
  mapping = NULL, data = NULL, stat = "identity", position = "identity"
)
  layer(
    data = data, mapping = mapping, stat = stat, geom = GeomPoint,
    position = position,
  )
```

Two non-obvious things `ggplot2::layer` does are: expand shortcut names for
`ggproto` objects into the corresponding `ggproto` object, and allocate
its other parameters to the different components.  In
`geom_point(position='jitter', size=2)`, `layer` translates the `'jitter'`
string into a `PositionJitter` `ggproto` object, and assigns the `size`
parameter to the aesthetic parameter list.  Implicitly due to the default value
for `stat` parameter it also translates the string `'identity'` into the
`StatIdentity` `ggproto` object.

`ggproto` objects contain logic (i.e. functions, a.k.a. methods) in addition to
data.  `ggplot_build` and `ggplot_gtable` will use these `ggproto` methods to
generate the plots.  In this way the layer extension mechanism allows us to
modify the plot generation mechanism.

**One major difference between `ggproto` methods and standard R functions**
is that the `ggproto` object is automatically passed to the method as the `self`
argument if the method defines it in its formals, as `method1` does and
`method2` does not:

```{r eval=TRUE}
Example <- ggproto(
  "Example", NULL,
  method1=function(self, x) cat(sprintf("%s %s\n", x, self$secret)),
  method2=function(x) cat(sprintf("%s %s\n", x, self$secret)),
  secret="secret"
)
Example$method1("big")
Example$method2("big")
```

## Data and Processing Patterns

The structure of `ggplot2` plots consists of:

* a plot
* that contains layers as specified by `geom_*` / `stat_*`
* that contain panels as specified by `facet_*`
* that contain groups as specified by the `group` aesthetic, or
  implicitly by the interaction of all the discrete aesthetics in the plot

Each layer has data associated to it.  It can be either layer specific data, or
data inherited from the plot itself (i.e. the data from `ggplot(data, ...)`).
The data is then divided across the panels and then across the groups by
adding the `PANEL` and `group` variables to the data.

Since data is not guaranteed to be associated with each layer until after the
`ggplot_build` process begins most of the `ggproto` objects have methods that
are called after the data are collected.  The two most common methods are:

* `setup_params()`
* `setup_data()`

These allow the `ggproto` objects to adjust parameters and data once the data
for each layer is collected.  This is useful for computing default values for
parameters that depend on the data, or to derive new aesthetics from existing
ones such as `xmin`/`xmax` values from `x` and `width` values.

Other methods present in most `Geom`, `Stat`, and `Position` that we are
interested in include:

* `compute_[layer|panel|group]()`
* `draw_[layer|panel|group]()`

Typically a `ggproto` object will have one set or the other.  For example `Geom`
objects have `draw_*` methods, whereas `Stat` objects have `compute_*` methods.
The method structure mirrors the data structure.  The `*_layer` methods are
called on the layer data, and they will typically call the `*_panel` methods
with the corresponding subset of the data, which then call the `*_group` methods
with the corresponding sub-subset of data.

The recommend approach to creating custom stats and geoms involves overriding
the `[compute|draw]_[panel|group]` methods for the `Geom*` and `Stat*` `ggproto`
objects..

## ggplot_build

### Outline

`ggplot_build` starts with the input data and the plot specification.  It then
proceeds through several steps that sequentially transform the data by adding
and/or recomputing variables, or in the case of statistics recomputing the
entire data.  In addition to transforming the data, the build process also
updates and computes meta data for scales, facets, etc.

Each of the steps is carried out by methods contained in the `Stat`,
`Geom`, `Position`, `Scale`, `Layer`, and other `ggproto` objects collected in
the plot specification step.  What follows is a listing of most of the method
calls in the build process.  This is intended as a reference so that you can
quickly identify where each `ggproto` object/method  is used in the build
process.

* For each layer:
    * `Layer$layer_data`: assign data to layer
* As part of `Layout$setup`:
    * `Facet$setup_params`:
    * `Facet$setup_data`:
    * `Coord$setup_data`:
    * `Facet$compute_layout`: assign `PANEL`, row, col, and x/y (position) scale
      ids to each facet (there are different scales when scales are "free").
    * `Coord$setup_layout`:
    * `Facet$map_data`: add the `PANEL` variable that maps data rows to facets.
* For each layer:
    * `Layer$compute_aesthetics`: compute aesthetics, add `group` variable.
* For each layer:
    * `Scale$transform_df`: apply scale transformations to aesthetics.
* `Layout$train_position`: initialize scales.
* `Layout$map_position`: For each layer, map position (x/y) scales.
* For each layer (`Layer$compute_statistic`):
    * `Stat$setup_params`: adjust stat parameters with updated version of data
    * `Stat$setup_data`: adjust data with update version of data and params
    * For each panel:
       * `Stat$compute_panel`: recompute data by applying statistic
       * or, For each group:
         * `Stat$compute_group`: recompute data by applying statistic


Illustrate with:
```{r, eval=FALSE}
dat <- data.frame(
  loc=(1:4)^2,
  val=(5:8)^2,
  grp=c('A', 'B', 'B', 'C'),
  pnl=c('P1', 'P1', 'P2', 'P2')
)
library(ggplot2)
p <- ggplot(dat, aes(x=loc, y=val, fill=grp)) +
  stat_bin2d() +
  geom_point(position="jitter", shape=21) +
  facet_wrap(~pnl, scales="free_x") +
  scale_x_sqrt() +
  scale_y_sqrt()
```

### Layer$layer_data

For each layer, this process assigns the data to be used, which is either the
data specified in the `geom_*`/`stat_*` call if any, or if not the data
specified in the `ggplot()` call.  Because neither layer in the plot had data
they both acquire the plot data.

### Facet$map_data

Add the `PANEL` variable to the data.  Here we show the effect it has on the
data of the first layer:

```{r, echo=FALSE}
input <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor")), .Names = c("loc", "val", "grp",
"pnl"), row.names = c(NA, -4L), class = "data.frame")
output <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor"), PANEL = structure(c(1L, 1L, 2L,
    2L), .Label = c("1", "2"), class = "factor")), .Names = c("loc",
"val", "grp", "pnl", "PANEL"), row.names = c(NA, 4L), class = "data.frame")
diffobj::diffPrint(input, output)
```

### Layer$compute_aesthetic

For each layer,  evaluates all the non-computed `aes(...)` expressions and
replace the data variables with the resulting aesthetics.  Computed aesthetics
(i.e. those containing calls to `stat`) are calculated later  **WHEN?**.  This
step also infers the `group` aesthetic from the interaction of categorical
variables specified in `aes(...)`.

Here we show the effect on one of the layer's data:

```{r, echo=FALSE}
input <- structure(list(loc = c(1, 4, 9, 16), val = c(25, 36, 49, 64),
    grp = structure(c(1L, 2L, 2L, 3L), .Label = c("A", "B", "C"
    ), class = "factor"), pnl = structure(c(1L, 1L, 2L, 2L), .Label = c("P1",
    "P2"), class = "factor"), PANEL = structure(c(1L, 1L, 2L,
    2L), .Label = c("1", "2"), class = "factor")), .Names = c("loc",
"val", "grp", "pnl", "PANEL"), row.names = c(NA, 4L), class = "data.frame")
output <- structure(list(x = c(1, 4, 9, 16), y = c(25, 36, 49, 64), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), row.names = c(NA, -4L), class = "data.frame")
diffobj::diffPrint(input, output)
```

The variable have changed to be the aesthetics, and we gain the `group`
variable.

### Scale$transform_df

This is applies scale transformations to each layer.  In our example, we use
`scale_*_sqrt`.  Here is the effect on the data for one of the layers:

```{r, echo=FALSE}
input <- structure(list(x = c(1, 4, 9, 16), y = c(25, 36, 49, 64), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), row.names = c(NA, -4L), class = "data.frame")
output <- structure(list(x = c(1, 2, 3, 4), y = c(5, 6, 7, 8), fill = structure(c(1L,
2L, 2L, 3L), .Label = c("A", "B", "C"), class = "factor"), PANEL = structure(c(1L,
1L, 2L, 2L), .Label = c("1", "2"), class = "factor"), group = structure(c(1L,
2L, 2L, 3L), n = 3L)), .Names = c("x", "y", "fill", "PANEL",
"group"), class = "data.frame", row.names = c(NA, -4L))
diffobj::diffPrint(input, output)
```

The transformation is applied to all the aesthetics that are associated with the
scale.  For example, continuous `x` scales will transform the `x` aesthetic, but
also `xmin`, `xmax`, `xend`, `xintercept`, and several others.

### Layout$map_position

For each layer, map data with position (x/y) scales.  This in theory would
rescale the position aesthetics (e.g. `x`, `xmin`, `xmax`, `y`, etc.), but
because "the coordinate system takes care of it" the only thing this does is
handle NAs and convert integer aesthetics to numeric.

### Stat$setup_params

#### Description

Provides an opportunity to check that parameters for a stat are correct, and to
update them as necessary, for example to provide defaults that need to be
computed from the data.

#### Signature

`Stat$setup_params([self], data, params)`

#### Parameters

* `self`: optional parameter, can be omitted from signature, but if present it
  is typically though not necessarily first.  It is the `ggproto` method that
  the object belongs to, which allows the method to access other components from
  that object.
* `data`: the layer data with computed and scale-transformed aesthetics, and
  with "mapped" position aesthetics.
* `params`: a list of the parameters provided to the layer instantiation
  function that match the parameters of the
  `Stat$compute_panel` method, and if that method has a `...` parameter, then
  also the parameters of the `Stat$compute_group` method.

### Stat$setup_data


### Stat$compute_panel


### Stat$compute_group



### Data Set-up

* Generate data for each layer, filling in with the plot data if necessary
* `Facet$setup_params()`: modifies facet parameters accounting for
  data (e.g. deriving default values for unspecified facet parameters).
  **Typically unused**.
* `Facet$setup_data()`:

  typically unused, allows modification of data.
* `Coord$setup_params()`
* `Coord$setup_data()`
* `Facet$compute_layout()`
* `Coord$setup_layout()`
* For each layer:
   * `Facet$map_data()` assigns data rows to facet panels.

### ggplot_gtable




the user
can call to provide the `GeomX` object in the plot specification step.  Then
`ggplot_build` (step 2) and `ggplot_gtable` will use the methods in the provided
`ggproto` object to manipulate the data and produce grobs.




## Hooks



1. Build (`ggplot_build`): analyzes and transforms data into a format suited for
   translation into graphical objects:
    1. Assigns facet panels.
    2. Computes aesthetic values from data and `aes(...)` specifications.
    3. Assigns groups.
    4. Rescales data if non linear scales are specified.
    5. Computes and maps statistics.
    6. Transforms special aesthetics (e.g. `width` to `xmin`-`xmax`)
       (Layer$compute_geom_1 -> Geom$setup_data, check_required_aesthetic)
    7. Adjusts positions (e.g. dodging/stacking with `$compute_positions`).
       (Layer$compute_positions ->
       Position$setup_params/setup_data/compute_layer)
    8. Recompute scales.
    9. Adds default aesthetics as needed.
2. Graphical Object Construction (`ggplot_gtable`):
    1. Applies coordinate transformations (if necessary)
    2. Translate the data into shapes, colors, positions, etc.
3. Rendering (`grid.draw`): display the resulting plot in a viewport.

Need to discuss what is implemented via the `ggproto` objects.

Each of the sub-steps in the build step is applied to every layer before moving
to the next step with the `by_layer` function.  Additionally, each proto driven
calculation follows this hierarchy:

`(draw|compute)_layer`
`(draw|compute)_panel`
`(draw|compute)_group`

The `*_layer` functions typically split the data by panel and forward each
chunk to the corresponding `*_panel` function.  The base `ggproto` `*_panel`
methods will split the data by group and forward it to the corresponding
`*_group` function.  This allows you to override either the `*_panel` or the
`*_group` function depending on what you are trying to do.

## Understanding the `data` Object

* Internal aesthetics
* Special variables (`group`, `panel`)
  * `group` are "integer" values from 1 to n where n is the number of groups, or
    -1 if there aren't any groups.
* Computed variables (`..level..`)

## Position Adjustments

Step 1.7 is carried out by modifying the coordinates in the data objects.
Both `position_dodge` and `position_stack` group data by `xmin` coordinate value
(either user provided, or derived from `x` and `width` or some such), and then
resolve any `xmin` overlaps by allocating the available width for each distinct
`group` (or should it be element?) within.

## Alternate Docs

### On `gg_proto`

Things to know:

* Objects that contain member functions and data
* The members can be accessed like list objects `object$member`
* When member functions are invoked they are always automatically provided with
  a `self` object if `self` is part of the signature (you can probably still
  access `self` even if it isn't in the sig, need to test).
* You cannot debug `ggproto` methods directly because they are wrapped on the
  fly by `$.ggproto`.  To debug, first extract the method, then `debug` it, then
  `debug` `f` inside of it...

### Ggplot Basics

### Mapping


### Rendering



Extending `ggplot` requires influencing how steps 1. and 2. are carried out.
This is done by creating layer functions (e.g. `geom_*` or `stat_*`) functions that return layers containing custom `Geom*` or `Stat*` objects.



```
 ## For reference, `sys.calls()` from a debugged `setup_data`:
 $ : language function (x, ...)  UseMethod("print")(x)
 $ : language print.ggplot(x)
 $ : language ggplot_build(x)
 $ : language by_layer(function(l, d) l$compute_geom_1(d))
 $ : language f(l = layers[[i]], d = data[[i]])
 $ : language l$compute_geom_1(d)
 $ : language f(..., self = self)
 $ : language self$geom$setup_data(data, c(self$geom_params, self$aes_params))
 $ : language f(...)
```

### Geom Basics

To implement a geom you need:

* A `geom_*` standard function
* A `Geom*` object, possibly re-used from an existing geom

### The `Geom*` Object

`Geom*` objects such as `GeomPoint` or `GeomRect` are responsible for
translating your data into graphical objects.  In `ggplot` these graphical
objects are called "grobs", short for Grid Graphical Objects, because they are
encoded in a format defined by the `grid` R package.  In order to create your
own geoms you will need to learn how to use `grid`, or alternatively to re-use
existing `Geom*` objects to generate grobs suited for your purposes.  For
example in this package we re-use `GeomRect` for `GeomWaterfall`.

`Geom*` objects are implemented using `ggproto`, a `ggplot2` specific Object
Oriented framework.  `ggproto` is derived from the `proto` R OOP package.



## Extending Ggplot 2 vignette

### What `ggplot2` Does

### Creating Geoms

The `setup_data` and `draw_panel` functions we referenced above are part of the
`Geom*` `ggproto` objects.

`setup_data` is used to convert parameters / aesthetics that are not in a format
amenable to plotting, to one that is.  One prime example is converting `width`
and `height` to `xmin/xmax` and `ymin/ymax` values.


In "Creating a new Geom", `draw_panel` is described as having 3 parameters,
instead of the 4 + (in particular starting with `self`) in other docs and in the
source.  Additionally, the `panel_scales` param appears to actually be
`panel_params`, at least in the sample fun we used (but `?Geom` also references
`panel_scales`).

For `draw_panel` sigs, we have

* `GeomPoint`: `function(data, panel_params, coord, na.rm = FALSE)`
* `GeomRect`: `function(self, data, panel_params, coord)`
* `Geom`: `function(self, data, panel_params, coord, ...)`

From what I can infer from docs and source your function must accept at least
three arguments.  `draw_layer` from `Geom` will call `draw_panel` with three
unnamed parameters that in theory should match up to `data`, `panel_params`,
`coord`.

* `data`: A data.frame with all the aesthetic values as specified via `aes`.
  The column names corresponding to the aesthetic names, not the original data
  frame column names.  Additionally contains `PANEL`, `group` (set to -1 if
  there are no groups), and any default aesthetics specified in
  `Geom*$default_aes`.
* `panel_params`: named list, the intersection of parameters provided to the
  `geom_*` function with the formals of the `draw_panel` method, although you
  can customize `Geom` objects to return a specific eligible parameter list.
* `coord`: coord transformation functions?

Additionally, named parameters that are the intersection of the parameters
provided to the `geom_*` function by the user and the parameters of `draw_panel`
are supplied.

Finally, since `draw_panel` is a `ggproto` method `self` will be provided if it
is part of the `draw_panel` signature.

## Deprecated Stuff

### `setup_data` vs `reparametrise`

It seems like both those functions can be used for the same purpose.  For
example, in `GeomRect`, `setup_data` is explicitly used to convert width to
`xmax/xmin`.

Actually, looks like `reparameterise` doesn't exist anymore?

draw_legend / draw_key

## Grid Stuff

You cannot use `gList` in the key/legend.  However, `grobTree` works.

[1]: https://cran.r-project.org/package=ggplot2/vignettes/extending-ggplot2.html

## Glossary

<dl>
  <dt><a name='grid'>Ggproto</dt>
  <dd>
  Object oriented framework used by `ggplot2`.  See `?ggplot2::ggproto` for
  details.
  </dd>
  <dt><a name='grid'>Grid</dt>
  <dd>
  Low level graphics package that comes packaged by default with R.  It is used
  by `ggplot` to draw the plots.  There are several useful vignettes you can
  find with `browseVignettes('grid')`.
  </dd>
  <dt><a name='grid-graphical-object'>Grid Graphical Objects</dt>
  <dd>
  A.k.a. grobs, R objects that contain description of graphical elements that
  can be used by the `grid` package to draw them on a graphical device.
  </dd>
  <dt><a name='layer-ggproto'></a>Layer</dt>
  <dd>
  `ggproto` object responsible for computing and rendering plot layers.  It
  contains `Geom`, `Stat`, and `Position` `ggproto` sub-objects, along with
  other data and the methods that carry out the computation and translation of
  layer data into [grobs](#grid-graphical-objects).
  </dd>
  <dt><a name='geom-ggproto'></a>Geom</dt>
  <dd>
  `ggproto` object responsible for translating the plot data into
  [grobs](#grid-grahpical-object).  You can extend `Geom` objects by overriding
  the [`Geom$setup_data`](#geom-setup-data),
  [`Geom$setup_param`](#geom-setup-param),
  [`Geom$draw_panel`](#geom-draw-panel),
  and/or [`Geom$draw_group`](#geom-draw-group) methods.
  </dd>
  <dt><a name='geom-ggproto'></a>Stat</dt>
  <dd>
  `ggproto` object responsible for recomputing the plot data with a
  statistic, e.g. by binning it and computing new `y` values as with `StatBin`.
  You can extend `Stat` objects by overriding
  the [`Stat$setup_data`](#stat-setup-data),
  [`Stat$setup_param`](#stat-setup-param),
  [`Stat$compute_panel`](#stat-compute-panel),
  and/or [`Stat$compute_group`](#stat-compute-group) methods.

  </dd>

  <dt>
    <a name='layer-instantiation-function'></a>Layer Instantiation Function
  </dt>
  <dd>
  Functions that create `Layer` `ggproto` objects like `geom_point` or
  `stat_bin`.  These functions will allocate their parameters to the various
  subcomponents of the `Layer` `ggproto` object such as the `Stat`, `Geom`, or
  `ggproto` objects

  Similar to a [Predicate Function](#predicate-function), may return either TRUE
  or a vector of only TRUE values on success, and something else on failure.
  `all.equal(x, y)` is a common example.  Check Functions should be used within
  `isTRUE(all(check_fun(...)))` to establish success or failure, unless they are
  used within `stopifnot` or `vetr` where such a check is implicit.
  </dd>

* Layer Instantiation Function:

